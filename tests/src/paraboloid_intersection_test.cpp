// This file is part of the Interface Reconstruction Library (IRL),
// a library for interface reconstruction and computational geometry operations.
//
// Copyright (C) 2019 Robert Chiodi <robert.chiodi@gmail.com>
//
// This Source Code Form is subject to the terms of the Mozilla Public
// License, v. 2.0. If a copy of the MPL was not distributed with this
// file, You can obtain one at https://mozilla.org/MPL/2.0/.

#include "irl/geometry/general/new_pt_calculation_functors.h"
#include "irl/geometry/general/pt_with_data.h"
#include "irl/geometry/general/rotations.h"
#include "irl/moments/volume_with_gradient.h"
#include "irl/paraboloid_reconstruction/gradient_paraboloid.h"

#include <cmath>
#include <random>

#include "gtest/gtest.h"

#include "irl/data_structures/small_vector.h"
#include "irl/generic_cutting/generic_cutting.h"
#include "irl/generic_cutting/half_edge_cutting/half_edge_cutting.h"
#include "irl/generic_cutting/paraboloid_intersection/paraboloid_intersection.h"
#include "irl/generic_cutting/paraboloid_intersection/paraboloid_intersection_amr.h"
#include "irl/geometry/general/normal.h"
#include "irl/geometry/general/plane.h"
#include "irl/geometry/half_edge_structures/half_edge_polyhedron_paraboloid.h"
#include "irl/geometry/half_edge_structures/segmented_half_edge_polyhedron_paraboloid.h"
#include "irl/geometry/polyhedrons/general_polyhedron.h"
#include "irl/geometry/polyhedrons/rectangular_cuboid.h"
#include "irl/interface_reconstruction_methods/progressive_distance_solver_paraboloid.h"
#include "irl/paraboloid_reconstruction/paraboloid.h"
#include "irl/paraboloid_reconstruction/parametrized_surface.h"
#include "irl/planar_reconstruction/planar_separator.h"
#include "tests/src/basic_mesh.h"
#include "tests/src/vtk.h"

namespace {

static const std::array<double, 64> x_gauss_64{{-0.0243502926634244325089558428537156614268871093149758091634531663960566965166295288529853061657116894882370493013671717560479926679408068852617342586968190919443025679363843727751902756254975073084367002129407854253246662805532069172532219089321005870178809284335033318073251039701073379759, 0.0243502926634244325089558428537156614268871093149758091634531663960566965166295288529853061657116894882370493013671717560479926679408068852617342586968190919443025679363843727751902756254975073084367002129407854253246662805532069172532219089321005870178809284335033318073251039701073379759, -0.0729931217877990394495429419403374932441261816687788533563163323377395217254429050181833064967505478802134768007678458612956459126148837496307967995621683597067400860540057918571357609346700883624064782909888895547912499697295335516804810990011835717296819569741981551097569810739977931249, 0.0729931217877990394495429419403374932441261816687788533563163323377395217254429050181833064967505478802134768007678458612956459126148837496307967995621683597067400860540057918571357609346700883624064782909888895547912499697295335516804810990011835717296819569741981551097569810739977931249, -0.1214628192961205544703764634922478782186836383371912940423495826006931832245070944213952236889690237679661122848626352437115925113582515415979746598665681268376919737373113667247142315234607397986222184384307059013512155412722263090766858403726100735651684437098923088469949297570988091677, 0.1214628192961205544703764634922478782186836383371912940423495826006931832245070944213952236889690237679661122848626352437115925113582515415979746598665681268376919737373113667247142315234607397986222184384307059013512155412722263090766858403726100735651684437098923088469949297570988091677, -0.1696444204239928180373136297482698441999902667343778505894178746884342357796505591325925801106834127602396624627746208498838190598644711533868179088757129652678801285453336384132061358206434768209251779433993367981112053126660575920785488821886662635718276505127786854167528795165050389903, 0.1696444204239928180373136297482698441999902667343778505894178746884342357796505591325925801106834127602396624627746208498838190598644711533868179088757129652678801285453336384132061358206434768209251779433993367981112053126660575920785488821886662635718276505127786854167528795165050389903, -0.217423643740007084149648748988822617578485831141222348630380401885689634737659235537163737740243604800759921292790013642836998201691226098978544332296437547642195961469059807833597096166848933098833151166287901339013986496737408125314858259377210847115061960167857239951500335854820530586, 0.217423643740007084149648748988822617578485831141222348630380401885689634737659235537163737740243604800759921292790013642836998201691226098978544332296437547642195961469059807833597096166848933098833151166287901339013986496737408125314858259377210847115061960167857239951500335854820530586, -0.2646871622087674163739641725100201179804131362950932439559895448126206429452852982016450901649805445999078728714943692622330016257776575354105370883948495294882935681426154386660616476411740312465060150591301869544672050088454083442813632094277160007745547301572849406353682760306061929911, 0.2646871622087674163739641725100201179804131362950932439559895448126206429452852982016450901649805445999078728714943692622330016257776575354105370883948495294882935681426154386660616476411740312465060150591301869544672050088454083442813632094277160007745547301572849406353682760306061929911, -0.3113228719902109561575126985601568835577153578680501269954571709858169098868398268719654999460149709757804582988077747605532896065842023340674450299515989484487746153929299031759475919924980452933324186984188982046762542556035347023744560814177013801414889023264804693830155588690576492164, 0.3113228719902109561575126985601568835577153578680501269954571709858169098868398268719654999460149709757804582988077747605532896065842023340674450299515989484487746153929299031759475919924980452933324186984188982046762542556035347023744560814177013801414889023264804693830155588690576492164, -0.357220158337668115950442615046202531626264464640909112021237019340099177403802509741325589540743874845093675632547750287037622834793938695456980400958079292460482315821150714268593539935795231095157602025909339384694681190969656053235824652679875951093689200190014853543993102190088381483, 0.357220158337668115950442615046202531626264464640909112021237019340099177403802509741325589540743874845093675632547750287037622834793938695456980400958079292460482315821150714268593539935795231095157602025909339384694681190969656053235824652679875951093689200190014853543993102190088381483, -0.4022701579639916036957667712601588487132652056150208082760431843129087214967261515969669708970990221669508217089555714806012046537594438323569293594638517933840725639831594134038262580440842200076281605641993773325072728778928440394419613403725280285705765326861533477990551765453978736181, 0.4022701579639916036957667712601588487132652056150208082760431843129087214967261515969669708970990221669508217089555714806012046537594438323569293594638517933840725639831594134038262580440842200076281605641993773325072728778928440394419613403725280285705765326861533477990551765453978736181, -0.4463660172534640879849477147589151892067507578262501763082606820212937626970791295735937384813941473610238854736863966831464694923749954564921955859791688348936235671762050333408576202492209167272366373825152067680845198006626563761196191045700093968519269790165913301841545609485952718504, 0.4463660172534640879849477147589151892067507578262501763082606820212937626970791295735937384813941473610238854736863966831464694923749954564921955859791688348936235671762050333408576202492209167272366373825152067680845198006626563761196191045700093968519269790165913301841545609485952718504, -0.4894031457070529574785263070219213908493732974637398373316540793240315585537584844752851087115581833443158831657759501916744927211636581386025171070582998790865902140901838128045602667002106847665927788023098753138400106615804847725751247952878407027140260429761863258319891988431055536872, 0.4894031457070529574785263070219213908493732974637398373316540793240315585537584844752851087115581833443158831657759501916744927211636581386025171070582998790865902140901838128045602667002106847665927788023098753138400106615804847725751247952878407027140260429761863258319891988431055536872, -0.531279464019894545658013903544455247408525588734180238053268047166041778398245121448843253296460411619816073385211875151397248937264089998182375345915413219579220233566173902955487674957069948591213673456625912506280248298229907928060620469290406581396192419570799497688513058132396498814, 0.531279464019894545658013903544455247408525588734180238053268047166041778398245121448843253296460411619816073385211875151397248937264089998182375345915413219579220233566173902955487674957069948591213673456625912506280248298229907928060620469290406581396192419570799497688513058132396498814, -0.5718956462026340342838781166591886431831910060912509932273284719418912212643223327597417735844776972648163821225207266145263395898251858906124801356522395225326954546582593857056725545247314092886133249957455688586118199388064447508712958637376347457406936802691416300157802889354368128467, 0.5718956462026340342838781166591886431831910060912509932273284719418912212643223327597417735844776972648163821225207266145263395898251858906124801356522395225326954546582593857056725545247314092886133249957455688586118199388064447508712958637376347457406936802691416300157802889354368128467, -0.6111553551723932502488529710185489186961245593079718443367976666933088374650288148448667879830703867726577720666491772560110368248450475818132595468834493579434418252468978282181164008820769765174450056817468275783966537351796625224747700783378315186174632657840114512887287754747902924865, 0.6111553551723932502488529710185489186961245593079718443367976666933088374650288148448667879830703867726577720666491772560110368248450475818132595468834493579434418252468978282181164008820769765174450056817468275783966537351796625224747700783378315186174632657840114512887287754747902924865, -0.6489654712546573398577612319934048855296904334732011728792502624366057598865738239773166627826358871699142531853930525866830933399401844502541092962631127742267449897116125748014270680393024011359139031312062573520509858894743036198986443014969748157931850178889912972291202354657382925509, 0.6489654712546573398577612319934048855296904334732011728792502624366057598865738239773166627826358871699142531853930525866830933399401844502541092962631127742267449897116125748014270680393024011359139031312062573520509858894743036198986443014969748157931850178889912972291202354657382925509, -0.6852363130542332425635583710313763019356410785396718681324042749913611976548967332647625541234155413035075739348863233240851709341392873173633850612006618690218164007761541855237208605116527909791956398350719463021018362527198358286721239529091637248252469435642287693207506339068528700205, 0.6852363130542332425635583710313763019356410785396718681324042749913611976548967332647625541234155413035075739348863233240851709341392873173633850612006618690218164007761541855237208605116527909791956398350719463021018362527198358286721239529091637248252469435642287693207506339068528700205, -0.7198818501716108268489402178319472447581380033149019526220473151184468592486433646042300919262498902882179891494724046747921544602557246455427317830132976771174504209146835854012577372395960646854355024460204286901035470812684876587693044068989973704915078171158689213412715251485203442313, 0.7198818501716108268489402178319472447581380033149019526220473151184468592486433646042300919262498902882179891494724046747921544602557246455427317830132976771174504209146835854012577372395960646854355024460204286901035470812684876587693044068989973704915078171158689213412715251485203442313, -0.7528199072605318966118637748856939855517142713220871932461987761167722639636968539390413583009467924995905147153923286347693864945784890119950315095740891764880991728646942920208355501445550654259850385377192973526980795946453961077798744753892199929235882097232836682421729944934586281945, 0.7528199072605318966118637748856939855517142713220871932461987761167722639636968539390413583009467924995905147153923286347693864945784890119950315095740891764880991728646942920208355501445550654259850385377192973526980795946453961077798744753892199929235882097232836682421729944934586281945, -0.7839723589433414076102205252137682840564141249898259334132759617476816578705098509357116190608002325895348207611752987335385494893726027026038902508685496606160441965948835252795524014713290879877269643684102005605450140247125536147801312017065532602835003540212221564314236937509990182173, 0.7839723589433414076102205252137682840564141249898259334132759617476816578705098509357116190608002325895348207611752987335385494893726027026038902508685496606160441965948835252795524014713290879877269643684102005605450140247125536147801312017065532602835003540212221564314236937509990182173, -0.8132653151227975597419233380863033406981418225655972166956485149356586346082019870309280128411412936411423614767918756843380999442447282903502051218203273573634847203121451086379808399639198510674436238195505371716160648058477202993836014352158139813219612968106205248494087577632573534973, 0.8132653151227975597419233380863033406981418225655972166956485149356586346082019870309280128411412936411423614767918756843380999442447282903502051218203273573634847203121451086379808399639198510674436238195505371716160648058477202993836014352158139813219612968106205248494087577632573534973, -0.840629296252580362751691544695873302982489823801755353928202683075593465893922171840726147868117503717663799561956411215937924134571068943700343442753760445948626598735504632170407243376224222403038093781056024445977626666740664628412660960413062370047183186652885532589557452614451434048, 0.840629296252580362751691544695873302982489823801755353928202683075593465893922171840726147868117503717663799561956411215937924134571068943700343442753760445948626598735504632170407243376224222403038093781056024445977626666740664628412660960413062370047183186652885532589557452614451434048, -0.8659993981540928197607833850701575024125019187582496425664279511808356713122188567857456842034906362573453815878913951040194915987006979015304835979058725276345799813088989383312475641092775164460639450521468294104011206574786429237252678172922104036725327539940502197291939132802457917836, 0.8659993981540928197607833850701575024125019187582496425664279511808356713122188567857456842034906362573453815878913951040194915987006979015304835979058725276345799813088989383312475641092775164460639450521468294104011206574786429237252678172922104036725327539940502197291939132802457917836, -0.8893154459951141058534040382728516224291944615104521893194744566084811090577722526400445910623711480590529533188832105988657269430913287263821624762648137092066620632787986348052306840101775313644572400860845559833367997001666659907951051347410546710134120144598833115095140475669485797579, 0.8893154459951141058534040382728516224291944615104521893194744566084811090577722526400445910623711480590529533188832105988657269430913287263821624762648137092066620632787986348052306840101775313644572400860845559833367997001666659907951051347410546710134120144598833115095140475669485797579, -0.9105221370785028057563806680083298610134880848883640292531723714467102234556291968179018775780308458024302103848451312741663820589200520720207891653884985710130867134073520525932445557074805974235006810370309087879564826639263972805682465506594098949560288847385983395160311034445386606259, 0.9105221370785028057563806680083298610134880848883640292531723714467102234556291968179018775780308458024302103848451312741663820589200520720207891653884985710130867134073520525932445557074805974235006810370309087879564826639263972805682465506594098949560288847385983395160311034445386606259, -0.9295691721319395758214901545592256073474270144297154975928116833612430986265594515998834499355844736686512805129688214992047597092114291955925880175797899765980745854426738149516325837607227287481909072315347776012991222301207304052068204069335766550173941103055407746774520789612843561385, 0.9295691721319395758214901545592256073474270144297154975928116833612430986265594515998834499355844736686512805129688214992047597092114291955925880175797899765980745854426738149516325837607227287481909072315347776012991222301207304052068204069335766550173941103055407746774520789612843561385, -0.9464113748584028160624814913472647952793949717952331902317789712973664402149436591260928179188420533516264142755452159723722786167537167514691534968355366202934342465086995943893699962972237343218079763936958985487264411542890941861254842843026890160131607678957282346112697993618567018237, 0.9464113748584028160624814913472647952793949717952331902317789712973664402149436591260928179188420533516264142755452159723722786167537167514691534968355366202934342465086995943893699962972237343218079763936958985487264411542890941861254842843026890160131607678957282346112697993618567018237, -0.9610087996520537189186141218971572067621146110378459494461586158623919945488992563976780806866203786216001498788310714552847469661399216303755820947005848739467276644122915754949838610353627723679982220628115164983443994552616161584523205789167087822341423097206088828267065770404672828066, 0.9610087996520537189186141218971572067621146110378459494461586158623919945488992563976780806866203786216001498788310714552847469661399216303755820947005848739467276644122915754949838610353627723679982220628115164983443994552616161584523205789167087822341423097206088828267065770404672828066, -0.9733268277899109637418535073522726680261452944551741758819139781978152256958453749994966038154125547612207903105020176172420237675899907788807087542221018040460410464083361271842759039530092449625891215101984663282728542290395875313124045226564547294745437773482395329023327909760431499638, 0.9733268277899109637418535073522726680261452944551741758819139781978152256958453749994966038154125547612207903105020176172420237675899907788807087542221018040460410464083361271842759039530092449625891215101984663282728542290395875313124045226564547294745437773482395329023327909760431499638, -0.9833362538846259569312993021568311169452475066237403837464872131233426128415470535606559721330818003585532628124845662897410684694651251174207713020897795837892725294581710205598344576799985346970638130204876060998657059283079767876980544166132523941283823202290746667358872631036031924711, 0.9833362538846259569312993021568311169452475066237403837464872131233426128415470535606559721330818003585532628124845662897410684694651251174207713020897795837892725294581710205598344576799985346970638130204876060998657059283079767876980544166132523941283823202290746667358872631036031924711, -0.9910133714767443207393823834433031136413494453907904852225427459378131658644129997345108950133770434340330151289100150097018332483423277136039914249575686591612502752158650205954671083696496347591169012794322303027309768195334920157669446268175983954105533989275308193580349506657360682085, 0.9910133714767443207393823834433031136413494453907904852225427459378131658644129997345108950133770434340330151289100150097018332483423277136039914249575686591612502752158650205954671083696496347591169012794322303027309768195334920157669446268175983954105533989275308193580349506657360682085, -0.9963401167719552793469245006763991232098575063402266121352522199507030568202208530946066801021703916301511794658310735397567341036554686814952726523955953805437164277655915410358813984246580862850974195805395101678543649116458555272523253307828290553873260588621490898443701779725568118502, 0.9963401167719552793469245006763991232098575063402266121352522199507030568202208530946066801021703916301511794658310735397567341036554686814952726523955953805437164277655915410358813984246580862850974195805395101678543649116458555272523253307828290553873260588621490898443701779725568118502, -0.9993050417357721394569056243456363119697121916756087760628072954617646543505331997843242376462639434945376776512170265314011232493020401570891594274831367800115383317335285468800574240152992751785027563437707875403545865305271045717258142571193695943317890367167086616955235477529427992282, 0.9993050417357721394569056243456363119697121916756087760628072954617646543505331997843242376462639434945376776512170265314011232493020401570891594274831367800115383317335285468800574240152992751785027563437707875403545865305271045717258142571193695943317890367167086616955235477529427992282}};
static const std::array<double, 64>
    w_gauss_64{
        {0.0486909570091397203833653907347499124426286922838743305086688042456914190998246107310291565645676057401607079939845156005172257043376703767287395573765236401039685866479381075274920900511719320271157129622463682509122641788910270632229694394595885032921037399187298767076084601033342936131,
         0.0486909570091397203833653907347499124426286922838743305086688042456914190998246107310291565645676057401607079939845156005172257043376703767287395573765236401039685866479381075274920900511719320271157129622463682509122641788910270632229694394595885032921037399187298767076084601033342936131,
         0.0485754674415034269347990667839781136875565447049294857111516761025158193093697039229163427633930410186232149083923688162761488505704450697417589593116703853157329164894580165517236877241308351214870169600093357854651930986960906313726182992933363325614247750209880050786299287510692780499,
         0.0485754674415034269347990667839781136875565447049294857111516761025158193093697039229163427633930410186232149083923688162761488505704450697417589593116703853157329164894580165517236877241308351214870169600093357854651930986960906313726182992933363325614247750209880050786299287510692780499,
         0.048344762234802957169769527158017809703692550609501080629442201445249828946429202156764153264348308119169811534137999799779908820312744765416129733427088646813066886130539178187597540312913636916139844188190193872629488730769015964208394624398401975043997268903006190530430762197842013971,
         0.048344762234802957169769527158017809703692550609501080629442201445249828946429202156764153264348308119169811534137999799779908820312744765416129733427088646813066886130539178187597540312913636916139844188190193872629488730769015964208394624398401975043997268903006190530430762197842013971,
         0.0479993885964583077281261798713460699543167134714936209446323930933335214619650277588138568504103427609283146728470455041360837549685364869161566863222680599110109210456299588352028330169041000166382937545505655464884266691630625402297821494221827392164049587946530563778771030124675514431,
         0.0479993885964583077281261798713460699543167134714936209446323930933335214619650277588138568504103427609283146728470455041360837549685364869161566863222680599110109210456299588352028330169041000166382937545505655464884266691630625402297821494221827392164049587946530563778771030124675514431,
         0.0475401657148303086622822069442231716408252512625387521584740318784735191312349586041971325618543660076682369564304738487584849740943805934034367382833518752314207901993991333786062812015195073547884746598535775062676699885664167707011249029305697669004958515813436770491520105115843742005,
         0.0475401657148303086622822069442231716408252512625387521584740318784735191312349586041971325618543660076682369564304738487584849740943805934034367382833518752314207901993991333786062812015195073547884746598535775062676699885664167707011249029305697669004958515813436770491520105115843742005,
         0.0469681828162100173253262857545810751998975284738125649829240886861900500181800807437012381630302198876925642461830694029139318555787845567143614289552410495903601238284556145544858090965965782916339169651505119399637862876053945518410353459767034026687936026945199383607112976484520939933,
         0.0469681828162100173253262857545810751998975284738125649829240886861900500181800807437012381630302198876925642461830694029139318555787845567143614289552410495903601238284556145544858090965965782916339169651505119399637862876053945518410353459767034026687936026945199383607112976484520939933,
         0.0462847965813144172959532492322611849696503075324468007778340818364698861774606986244241539105685321088517142947579291476238551538798963436740600968513359005801910700069462154098456091711311098901749803777735222026075473081311483686560830539773763176758567914860207820170792365910140063798,
         0.0462847965813144172959532492322611849696503075324468007778340818364698861774606986244241539105685321088517142947579291476238551538798963436740600968513359005801910700069462154098456091711311098901749803777735222026075473081311483686560830539773763176758567914860207820170792365910140063798,
         0.0454916279274181444797709969712690588873234618023998968168834081606504637618082102750954507142497706775055424364453740562113890878382679420378787427100982909191308430750899201141096789461078632697297091763378573830284133736378128577579722120264252594541491899441765769262904055702701625378,
         0.0454916279274181444797709969712690588873234618023998968168834081606504637618082102750954507142497706775055424364453740562113890878382679420378787427100982909191308430750899201141096789461078632697297091763378573830284133736378128577579722120264252594541491899441765769262904055702701625378,
         0.0445905581637565630601347100309448432940237999912217256432193286861948363377761089569585678875932857237669096941854082976565514031401996407675401022860761183118504326746863327792604337217763335682212515058414863183914930810334329596384915832703655935958010948424747251920190851700662833367,
         0.0445905581637565630601347100309448432940237999912217256432193286861948363377761089569585678875932857237669096941854082976565514031401996407675401022860761183118504326746863327792604337217763335682212515058414863183914930810334329596384915832703655935958010948424747251920190851700662833367,
         0.0435837245293234533768278609737374809227888974971180150532193925502569499020021803936448815937567079991401855477391110804568848623412043870399620479222000249538880795788245633051476595555730388360811011823841525667998427392843673284072004068821750061964976796287623004834501604656318714989,
         0.0435837245293234533768278609737374809227888974971180150532193925502569499020021803936448815937567079991401855477391110804568848623412043870399620479222000249538880795788245633051476595555730388360811011823841525667998427392843673284072004068821750061964976796287623004834501604656318714989,
         0.0424735151236535890073397679088173661655466481806496697314607722055245433487169327182398988553670128358787507582463602377168227019625334754497484024668087975720049504975593281010888062806587161032924284354938115463233015024659299046001504100674918329532481611571863222497170398830691222425,
         0.0424735151236535890073397679088173661655466481806496697314607722055245433487169327182398988553670128358787507582463602377168227019625334754497484024668087975720049504975593281010888062806587161032924284354938115463233015024659299046001504100674918329532481611571863222497170398830691222425,
         0.0412625632426235286101562974736380477399306355305474105429034779122704951178045914463267035032832336161816547420067160277921114474557623647771372636679857599931025531633255548770293397336318597716427093310378312957479805159734598610664983115148350548735211568465338522875618805992499897174,
         0.0412625632426235286101562974736380477399306355305474105429034779122704951178045914463267035032832336161816547420067160277921114474557623647771372636679857599931025531633255548770293397336318597716427093310378312957479805159734598610664983115148350548735211568465338522875618805992499897174,
         0.0399537411327203413866569261283360739186769506703336301114037026981570543670430333260307390357287606111017588757685176701688554806178713759519003171090525332423003042251947304213502522332118258365256241174986409729902714098049024753746340158430732115642207673265332738358717839602955875715,
         0.0399537411327203413866569261283360739186769506703336301114037026981570543670430333260307390357287606111017588757685176701688554806178713759519003171090525332423003042251947304213502522332118258365256241174986409729902714098049024753746340158430732115642207673265332738358717839602955875715,
         0.0385501531786156291289624969468089910127871122017180319662378854088005271323682681394418540442928363090545214563022868422017877042243007014244875098498616146404178795110038170109976252865902624380463581094085479557660525450020049773872343621719025128277593787164021147974906095237533202082,
         0.0385501531786156291289624969468089910127871122017180319662378854088005271323682681394418540442928363090545214563022868422017877042243007014244875098498616146404178795110038170109976252865902624380463581094085479557660525450020049773872343621719025128277593787164021147974906095237533202082,
         0.0370551285402400460404151018095833750834649453056563021747536272028091562122966687178302646649066832960609370472485057031765338738734008482025086366647963664178752038995704175623165041724901843573087856883034472545386037691055680911138721623610172486110313241291773258491882452773847899443,
         0.0370551285402400460404151018095833750834649453056563021747536272028091562122966687178302646649066832960609370472485057031765338738734008482025086366647963664178752038995704175623165041724901843573087856883034472545386037691055680911138721623610172486110313241291773258491882452773847899443,
         0.0354722132568823838106931467152459479480946310024100946926514848199381113651392962399922996268087884509143420993419937430515415557908457195618550238075571721209638845910166697234073788332647695349442265578792857058786796417110738673392400570019770741873271724201517438135222598792344040215,
         0.0354722132568823838106931467152459479480946310024100946926514848199381113651392962399922996268087884509143420993419937430515415557908457195618550238075571721209638845910166697234073788332647695349442265578792857058786796417110738673392400570019770741873271724201517438135222598792344040215,
         0.0338051618371416093915654821107254310210499263140045346675500650400323727745785853730452808963944098691936344225349051741060036935288424090581463711756382878498537611980973238606529148664990420534952057130296232922368792280098852092993207644225150541876980292972087619863453425206929192216,
         0.0338051618371416093915654821107254310210499263140045346675500650400323727745785853730452808963944098691936344225349051741060036935288424090581463711756382878498537611980973238606529148664990420534952057130296232922368792280098852092993207644225150541876980292972087619863453425206929192216,
         0.032057928354851553585467504347898716966221573881398062250169407854535275399124366530227987935629046729162364779969274126431870966979526186907589490002269660893281421728773647001279141626157958271220102615163092206489916992120482595587916535390136003611498634162765724522022671474313619317,
         0.032057928354851553585467504347898716966221573881398062250169407854535275399124366530227987935629046729162364779969274126431870966979526186907589490002269660893281421728773647001279141626157958271220102615163092206489916992120482595587916535390136003611498634162765724522022671474313619317,
         0.030234657072402478867974059819548659158281397768481241636026542045969161851838118212761980885178641520596873511042783163461341979185470882574743804555268086640389062237383427702813367624714014426121485626242067362445894463989335423458464954799181190120473168677930333898873084606011285311,
         0.030234657072402478867974059819548659158281397768481241636026542045969161851838118212761980885178641520596873511042783163461341979185470882574743804555268086640389062237383427702813367624714014426121485626242067362445894463989335423458464954799181190120473168677930333898873084606011285311,
         0.0283396726142594832275113052002373519812075841257543359907955185084500175712880712901834579816476269393013386531176072296695948860841466158639973753393323262188023471133258509422081952937349849822864752636994881600343083839805990853930436233762729622213044478376753949590318846038229829528,
         0.0283396726142594832275113052002373519812075841257543359907955185084500175712880712901834579816476269393013386531176072296695948860841466158639973753393323262188023471133258509422081952937349849822864752636994881600343083839805990853930436233762729622213044478376753949590318846038229829528,
         0.0263774697150546586716917926252251856755993308422457184496156736853021592428967790284780487213653480867620409279447766944383920384284787790772384251090745670478105870527396429136326932261251511732466974897397268573168068852344129736214469830280087710575094607457344820944885011053938108899,
         0.0263774697150546586716917926252251856755993308422457184496156736853021592428967790284780487213653480867620409279447766944383920384284787790772384251090745670478105870527396429136326932261251511732466974897397268573168068852344129736214469830280087710575094607457344820944885011053938108899,
         0.0243527025687108733381775504090689876499784155133784119819985685535536787083770723737264828464464223276155821319330210193549896426801083040150047332857692873011433649334477370145389017577189505240415125600908800786897201425473757275187332157593198572919772969833130729981971352463730545469,
         0.0243527025687108733381775504090689876499784155133784119819985685535536787083770723737264828464464223276155821319330210193549896426801083040150047332857692873011433649334477370145389017577189505240415125600908800786897201425473757275187332157593198572919772969833130729981971352463730545469,
         0.0222701738083832541592983303841550024229592905997594051455205429744914460867081990116647982811451138592401156680063927909718825845915896692701716212710541472344073624315399429951255221519263275095347974129106415903376085208797420439500915674568159744176912567285070988940509294826076696882,
         0.0222701738083832541592983303841550024229592905997594051455205429744914460867081990116647982811451138592401156680063927909718825845915896692701716212710541472344073624315399429951255221519263275095347974129106415903376085208797420439500915674568159744176912567285070988940509294826076696882,
         0.0201348231535302093723403167285438970895266801007919519220072343276769828211923597982299498416998597995443052252531684909219367615574440281549241161294448697202959593344989612626641188010558013085389491205901106884167596038790695150496733123662891637942237462337673353651179115491957031948,
         0.0201348231535302093723403167285438970895266801007919519220072343276769828211923597982299498416998597995443052252531684909219367615574440281549241161294448697202959593344989612626641188010558013085389491205901106884167596038790695150496733123662891637942237462337673353651179115491957031948,
         0.0179517157756973430850453020011193688971673570364158572977184273569247295870620984743089140579199272107974903016785911970727080884655646148340637373001805876560334052431930062983734905886704331100259778249929425439377011315288821865303197904492848823994202996722656114004109123107733596987,
         0.0179517157756973430850453020011193688971673570364158572977184273569247295870620984743089140579199272107974903016785911970727080884655646148340637373001805876560334052431930062983734905886704331100259778249929425439377011315288821865303197904492848823994202996722656114004109123107733596987,
         0.0157260304760247193219659952975397944260290098431565121528943932284210502164124556525745628476326997189475680077625258949765335021586482683126547283634704087193102431454662772463321304938516661086261262080252305539171654570677889578063634007609097342035360186636479612243231917699790225637,
         0.0157260304760247193219659952975397944260290098431565121528943932284210502164124556525745628476326997189475680077625258949765335021586482683126547283634704087193102431454662772463321304938516661086261262080252305539171654570677889578063634007609097342035360186636479612243231917699790225637,
         0.0134630478967186425980607666859556841084257719773496708184682785221983598894666268489697837056105038485845901773961664652581563686185523959473293683490869846700009741156668864960127745507806046701586435579547632680339906665338521813319281296935586498194608460412423723103161161922347608637,
         0.0134630478967186425980607666859556841084257719773496708184682785221983598894666268489697837056105038485845901773961664652581563686185523959473293683490869846700009741156668864960127745507806046701586435579547632680339906665338521813319281296935586498194608460412423723103161161922347608637,
         0.011168139460131128818590493019208135072778797816827287215251362273969701224836131369547661822970774719521543690039908073147476182135228738610704246958518755712518444434075738269866120460156365855324768445411463643114925829148750923090201475035559533993035986264487097245733097728698218563,
         0.011168139460131128818590493019208135072778797816827287215251362273969701224836131369547661822970774719521543690039908073147476182135228738610704246958518755712518444434075738269866120460156365855324768445411463643114925829148750923090201475035559533993035986264487097245733097728698218563,
         0.0088467598263639477230309146597306476951762660792204997984715769296110380005985367341694286322550520156167431790573509593010611842062630262878798782558974712042810219159674181580449655112696028911646066461502678711637780164986283350190669684468398617127841853445303466680698660632269500149,
         0.0088467598263639477230309146597306476951762660792204997984715769296110380005985367341694286322550520156167431790573509593010611842062630262878798782558974712042810219159674181580449655112696028911646066461502678711637780164986283350190669684468398617127841853445303466680698660632269500149,
         0.0065044579689783628561173603999812667711317610549523400952448792575685125717613068203530526491113296049409911387320826711045787146267036866881961532403342811327869183281273743976710008917886491097375367147212074243884772614562628844975421736416404173672075979097191581386023407454532945934,
         0.0065044579689783628561173603999812667711317610549523400952448792575685125717613068203530526491113296049409911387320826711045787146267036866881961532403342811327869183281273743976710008917886491097375367147212074243884772614562628844975421736416404173672075979097191581386023407454532945934,
         0.0041470332605624676352875357285514153133028192536848024628763661431834776690157393776820933106187137592011723199002845429836606307797425496666456172753165824787973801175029578301513761259541022471768825518482406145696380621686627285992715643614469568410535180218496973657001203470470418364,
         0.0041470332605624676352875357285514153133028192536848024628763661431834776690157393776820933106187137592011723199002845429836606307797425496666456172753165824787973801175029578301513761259541022471768825518482406145696380621686627285992715643614469568410535180218496973657001203470470418364,
         0.0017832807216964329472960791449719331799593472719279556695308063655858546954239803486698215802150348282744786016134857283616955449868451969230490863774274598030023211055562492709717566919237924255297982774711177411074145151155610163293142044147991553384925940046957893721166251082473659733,
         0.0017832807216964329472960791449719331799593472719279556695308063655858546954239803486698215802150348282744786016134857283616955449868451969230490863774274598030023211055562492709717566919237924255297982774711177411074145151155610163293142044147991553384925940046957893721166251082473659733}};

using namespace IRL;

// TEST(ParaboloidIntersection, findIntercepts) {
//   RectangularCuboid cube = unit_cell;
//   StackVector<Pt, 2> intercepts;

//   AlignedParaboloid aligned_paraboloid;

//   aligned_paraboloid[0] = 0.0;
//   aligned_paraboloid[1] = 0.0;
//   aligned_paraboloid[2] = 1.0;
//   checkAndFindIntercepts(aligned_paraboloid, cube[0], cube[3], &intercepts);
//   EXPECT_EQ(intercepts.size(), 1);
//   EXPECT_NEAR(intercepts[0][0], 0.5, DBL_EPSILON);
//   EXPECT_NEAR(intercepts[0][1], -0.5, DBL_EPSILON);
//   EXPECT_NEAR(intercepts[0][2], 0.0, DBL_EPSILON);

//   aligned_paraboloid[0] = 0.25;
//   aligned_paraboloid[1] = 0.25;
//   aligned_paraboloid[2] = 1.0;
//   checkAndFindIntercepts(aligned_paraboloid, cube[0], cube[3], &intercepts);
//   EXPECT_EQ(intercepts.size(), 1);
//   EXPECT_NEAR(intercepts[0][0], 0.5, DBL_EPSILON);
//   EXPECT_NEAR(intercepts[0][1], -0.5, DBL_EPSILON);
//   EXPECT_NEAR(intercepts[0][2], 0.125, DBL_EPSILON);

//   aligned_paraboloid[0] = 4.0;
//   aligned_paraboloid[1] = 0.0;
//   aligned_paraboloid[2] = 1.0;
//   checkAndFindIntercepts(aligned_paraboloid, cube[0], cube[4], &intercepts);
//   EXPECT_EQ(intercepts.size(), 0);

//   aligned_paraboloid[0] = 4.0;
//   aligned_paraboloid[1] = 0.0;
//   aligned_paraboloid[2] = 1.0;
//   checkAndFindIntercepts(aligned_paraboloid, cube[3], cube[7], &intercepts);
//   EXPECT_EQ(intercepts.size(), 2);
//   EXPECT_NEAR(intercepts[0][0], 0.5 - (0.5 + std::sqrt(2.0) / 4.0),
//               DBL_EPSILON);
//   EXPECT_NEAR(intercepts[0][1], -0.5, DBL_EPSILON);
//   EXPECT_NEAR(intercepts[0][2], 0.5, DBL_EPSILON);
//   EXPECT_NEAR(intercepts[1][0], 0.5 - (0.5 - std::sqrt(2.0) / 4.0),
//               DBL_EPSILON);
//   EXPECT_NEAR(intercepts[1][1], -0.5, DBL_EPSILON);
//   EXPECT_NEAR(intercepts[1][2], 0.5, DBL_EPSILON);
// }

// TEST(ParaboloidIntersection, ParaboloidToAligned) {
//   Paraboloid x_aligned;
//   x_aligned.a() = 0.0;
//   x_aligned.b() = 1.0;
//   x_aligned.c() = 0.0;
//   x_aligned.d() = 1.0;
//   x_aligned.e() = -2.0;
//   x_aligned.f() = 1.0;
//   Pt translation;
//   UnitQuaternion rotation;
//   auto aligned_paraboloid =
//       x_aligned.generateAlignedParaboloid(&translation, &rotation);
//   std::cout << aligned_paraboloid.a() << " " << aligned_paraboloid.b()
//             << std::endl;
//   std::cout << translation << std::endl;
//   std::cout << rotation << std::endl;
// }

// TEST(ParaboloidIntersection, ParaboloidIntersection) {
//   RectangularCuboid cube = unit_cell;

//   AlignedParaboloid aligned_paraboloid;
//   aligned_paraboloid[0] = 0.25;
//   aligned_paraboloid[1] = 0.25;
//   aligned_paraboloid[2] = 1.0;

//   auto half_edge = cube.generateHalfEdgeVersion();
//   auto segmented_half_edge =
//       castForParaboloidUse(half_edge.generateSegmentedPolyhedron());
//   // formParaboloidIntersectionBases(&segmented_half_edge, &half_edge,
//   //                                 aligned_paraboloid);
//   // EXPECT_TRUE(segmented_half_edge.getNumberOfVertices() == 8);
//   // EXPECT_TRUE(segmented_half_edge.getNumberOfFaces() == 6);

//   Paraboloid full_paraboloid;
//   // full_paraboloid.a() = -8.0;
//   // full_paraboloid.b() = 10.0;
//   // full_paraboloid.c() = 10.0;
//   // full_paraboloid.d() = 20.0;
//   // full_paraboloid.e() = 400.0;
//   // full_paraboloid.f() = 20.0;
//   full_paraboloid.a() = 0.0;
//   full_paraboloid.b() = 0.0;
//   full_paraboloid.c() = 0.0;
//   full_paraboloid.d() = 0.25;
//   full_paraboloid.e() = 0.0;
//   full_paraboloid.f() = 20.0;
//   // full_paraboloid.a() = 0.0;
//   // full_paraboloid.b() = 0.0;
//   // full_paraboloid.c() = 0.0;
//   // full_paraboloid.d() = 20.0;
//   // full_paraboloid.e() = 0.0;
//   // full_paraboloid.f() = 20.0;
//   cube.setHalfEdgeVersion(&half_edge);
//   segmented_half_edge =
//       castForParaboloidUse(half_edge.generateSegmentedPolyhedron());
//   std::cout << segmented_half_edge;
//   formParaboloidIntersectionBases(&segmented_half_edge, &half_edge,
//                                   full_paraboloid);
//   std::cout << segmented_half_edge;

//   // aligned_paraboloid[0] = 4.0;
//   // aligned_paraboloid[1] = 0.0;
//   //  aligned_paraboloid[2] = 1.0;
//   // cube.setHalfEdgeVersion(&half_edge);
//   // segmented_half_edge = half_edge.generateSegmentedPolyhedron();
//   // formParaboloidIntersectionBases(&segmented_half_edge, &half_edge,
//   //                                 aligned_paraboloid);
//   // std::cout << segmented_half_edge;
// }

// TEST(ParaboloidIntersection, PlaneDegenerate) {
//   RectangularCuboid cube = unit_cell;
//   auto half_edge = cube.generateHalfEdgeVersion();

//   std::random_device
//       rd;  // Get a random seed from the OS entropy device, or whatever
//   std::mt19937_64 eng(rd());  // Use the 64-bit Mersenne Twister 19937
//                               // generator and seed it with entropy.
//   static const int ncycles = 1;
//   std::uniform_real_distribution<double> random_p_coeff(0.0, 0.5);
//   std::uniform_real_distribution<double> random_dist(-0.4, 0.4);

//   for (UnsignedIndex_t cycle = 0; cycle < ncycles; ++cycle) {
//     Paraboloid full_paraboloid;

//     full_paraboloid.a() = 0.35019353824427479;   // random_dist(eng);
//     full_paraboloid.b() = 0.074218750171035186;  // random_p_coeff(eng);
//     full_paraboloid.c() = 0.46792335784546885;   // random_p_coeff(eng);
//     full_paraboloid.d() = 0.0;
//     full_paraboloid.e() = 0.0;
//     full_paraboloid.f() = 0.0;
//     cube.setHalfEdgeVersion(&half_edge);
//     auto segmented_half_edge = half_edge.generateSegmentedPolyhedron();
//     auto normal = Normal(full_paraboloid.b(), full_paraboloid.c(), 1.0);
//     const double factor = normal.calculateMagnitude();
//     normal.normalize();
//     auto cutting_plane = PlanarSeparator::fromOnePlane(
//         Plane(normal, full_paraboloid.a() / factor));
//     cube.setHalfEdgeVersion(&half_edge);
//     segmented_half_edge = half_edge.generateSegmentedPolyhedron();
//     truncateHalfEdgePolytope(&segmented_half_edge, &half_edge,
//                              cutting_plane[0]);
//     auto plane_volume = segmented_half_edge.calculateVolume();
//     std::cout << segmented_half_edge << std::endl;

//     cube.setHalfEdgeVersion(&half_edge);
//     auto paraboloid_segmented_half_edge =
//         castForParaboloidUse(half_edge.generateSegmentedPolyhedron());
//     formParaboloidIntersectionBases(&paraboloid_segmented_half_edge,
//     &half_edge,
//                                     full_paraboloid);
//     auto paraboloid_volume =
//     paraboloid_segmented_half_edge.calculateVolume();

//     // auto plane_volume = getVolumeMoments<Volume>(cube, cutting_plane);
//     EXPECT_NEAR(paraboloid_volume, plane_volume, 1.0e-15)
//         << "Paraboloid coefficients " << full_paraboloid.a() << " "
//         << full_paraboloid.b() << " " << full_paraboloid.c() << " 0.0 0.0 0.0
//         "
//         << std::endl
//         << paraboloid_segmented_half_edge;
//   }
// }

TEST(ParaboloidIntersection, NonConvexW) {
  AlignedParaboloid aligned_paraboloid;
  aligned_paraboloid.a() = 1.0;
  aligned_paraboloid.b() = -10.0;

  std::vector<Pt> vertices{
      Pt(0.0, 0.0, 0.0),  Pt(1.0, 0.0, 0.0),  Pt(2.0, 2.0, 0.0),
      Pt(3.0, 0.0, 0.0),  Pt(4.0, 0.0, 0.0),  Pt(4.0, 3.0, 0.0),
      Pt(3.0, 0.25, 0.0), Pt(2.0, 3.0, 0.0),  Pt(1.0, 0.25, 0.0),
      Pt(0.0, 3.0, 0.0),  Pt(0.0, 0.0, 1.0),  Pt(1.0, 0.0, 1.0),
      Pt(2.0, 2.0, 1.0),  Pt(3.0, 0.0, 1.0),  Pt(4.0, 0.0, 1.0),
      Pt(4.0, 3.0, 1.0),  Pt(3.0, 0.25, 1.0), Pt(2.0, 3.0, 1.0),
      Pt(1.0, 0.25, 1.0), Pt(0.0, 3.0, 1.0)};

  for (auto& vert : vertices) {
    vert[0] -= 2.5;
    vert[1] -= 1.5;
  }

  std::vector<std::vector<UnsignedIndex_t>> conn;
  conn.push_back(std::vector<UnsignedIndex_t>{9, 8, 7, 6, 5, 4, 3, 2, 1, 0});
  conn.push_back(
      std::vector<UnsignedIndex_t>{10, 11, 12, 13, 14, 15, 16, 17, 18, 19});
  conn.push_back(std::vector<UnsignedIndex_t>{0, 1, 11, 10});
  conn.push_back(std::vector<UnsignedIndex_t>{1, 2, 12, 11});
  conn.push_back(std::vector<UnsignedIndex_t>{2, 3, 13, 12});
  conn.push_back(std::vector<UnsignedIndex_t>{3, 4, 14, 13});
  conn.push_back(std::vector<UnsignedIndex_t>{4, 5, 15, 14});
  conn.push_back(std::vector<UnsignedIndex_t>{5, 6, 16, 15});
  conn.push_back(std::vector<UnsignedIndex_t>{6, 7, 17, 16});
  conn.push_back(std::vector<UnsignedIndex_t>{7, 8, 18, 17});
  conn.push_back(std::vector<UnsignedIndex_t>{8, 9, 19, 18});
  conn.push_back(std::vector<UnsignedIndex_t>{9, 0, 10, 19});
  PolyhedronConnectivity connectivity(conn);

  GeneralPolyhedron poly(vertices, &connectivity);
  HalfEdgePolyhedronParaboloid<Pt> half_edge;
  poly.setHalfEdgeVersion(&half_edge);

  auto segmented_half_edge = half_edge.generateSegmentedPolyhedron();

  std::cout << "ORIGINAL\n" << segmented_half_edge << std::endl;

  auto volume = intersectPolyhedronWithParaboloid<VolumeMoments>(
      &segmented_half_edge, &half_edge, aligned_paraboloid);

  std::cout << "CUT\n" << segmented_half_edge << std::endl;
}

TEST(ParaboloidIntersection, FaceIntegration) {
  RectangularCuboid cube = unit_cell;
  HalfEdgePolyhedronParaboloid<Pt> half_edge;
  cube.setHalfEdgeVersion(&half_edge);

  AlignedParaboloid aligned_paraboloid;
  aligned_paraboloid.a() = -8.0;
  aligned_paraboloid.b() = -8.0;
  aligned_paraboloid[2] = 1.0;
  auto segmented_half_edge = half_edge.generateSegmentedPolyhedron();
  auto volume = intersectPolyhedronWithParaboloid<VolumeMoments>(
      &segmented_half_edge, &half_edge, aligned_paraboloid);
  std::cout << "VolumeMoments " << volume << std::endl;
  auto face_plane = Plane(Normal(0.0, 0.0, 1.0), 0.5);
  double a = -face_plane.normal()[0] / face_plane.normal()[2];
  double b = -face_plane.normal()[1] / face_plane.normal()[2];
  double c = face_plane.distance() / face_plane.normal()[2];
  Volume expected_volume =
      M_PI *
      (4.0 * aligned_paraboloid.a() * aligned_paraboloid.b() * c +
       aligned_paraboloid.a() * b * b + aligned_paraboloid.b() * a * a) *
      std::fabs((4.0 * aligned_paraboloid.a() * aligned_paraboloid.b() * c +
                 aligned_paraboloid.a() * b * b +
                 aligned_paraboloid.b() * a * a)) /
      (32.0 * std::pow(aligned_paraboloid.a() * aligned_paraboloid.b(), 2.5));
  EXPECT_NEAR(volume.volume(), expected_volume, 1.0e-15);

  // Test double face intersection
  for (auto& pt : cube) {
    pt[2] += -1.0;
  }
  cube.setHalfEdgeVersion(&half_edge);
  segmented_half_edge = half_edge.generateSegmentedPolyhedron();
  volume = intersectPolyhedronWithParaboloid<VolumeMoments>(
      &segmented_half_edge, &half_edge, aligned_paraboloid);
  face_plane = Plane(Normal(0.0, 0.0, -1.0), -0.5);
  a = -face_plane.normal()[0] / face_plane.normal()[2];
  b = -face_plane.normal()[1] / face_plane.normal()[2];
  c = face_plane.distance() / face_plane.normal()[2];
  expected_volume = -std::fabs(
      M_PI *
      (4.0 * aligned_paraboloid.a() * aligned_paraboloid.b() * c +
       aligned_paraboloid.a() * b * b + aligned_paraboloid.b() * a * a) *
      std::fabs((4.0 * aligned_paraboloid.a() * aligned_paraboloid.b() * c +
                 aligned_paraboloid.a() * b * b +
                 aligned_paraboloid.b() * a * a)) /
      (32.0 * std::pow(aligned_paraboloid.a() * aligned_paraboloid.b(), 2.5)));
  face_plane = Plane(Normal(0.0, 0.0, 1.0), 1.5);
  a = -face_plane.normal()[0] / face_plane.normal()[2];
  b = -face_plane.normal()[1] / face_plane.normal()[2];
  c = face_plane.distance() / face_plane.normal()[2];
  expected_volume += std::fabs(
      M_PI *
      (4.0 * aligned_paraboloid.a() * aligned_paraboloid.b() * c +
       aligned_paraboloid.a() * b * b + aligned_paraboloid.b() * a * a) *
      std::fabs((4.0 * aligned_paraboloid.a() * aligned_paraboloid.b() * c +
                 aligned_paraboloid.a() * b * b +
                 aligned_paraboloid.b() * a * a)) /
      (32.0 * std::pow(aligned_paraboloid.a() * aligned_paraboloid.b(), 2.5)));
  EXPECT_NEAR(volume.volume(), expected_volume, 1.0e-15);
}

TEST(ParaboloidIntersection, EllipticDoubleIntercept) {
  RectangularCuboid cube = unit_cell;
  for (auto& pt : cube) {
    pt[0] += 0.5;
  }
  HalfEdgePolyhedronParaboloid<Pt> half_edge;
  cube.setHalfEdgeVersion(&half_edge);

  AlignedParaboloid aligned_paraboloid;
  aligned_paraboloid.a() = -16.0;
  aligned_paraboloid.b() = -16.0;

  auto segmented_half_edge = half_edge.generateSegmentedPolyhedron();
  Volume volume = intersectPolyhedronWithParaboloid<Volume>(
      &segmented_half_edge, &half_edge, aligned_paraboloid);
}

TEST(ParaboloidIntersection, AlignedSingleIntersection) {
  RectangularCuboid cube = unit_cell;
  HalfEdgePolyhedronParaboloid<Pt> half_edge;
  cube.setHalfEdgeVersion(&half_edge);

  AlignedParaboloid aligned_paraboloid;
  aligned_paraboloid.a() = 0.25;
  aligned_paraboloid.b() = 0.25;
  aligned_paraboloid[2] = 1.0;
  Volume expected_volume =
      0.5 * (cube[2][1] - cube[4][1]) * (cube[2][0] - cube[4][0]) +
      1.0 / 3.0 *
          (aligned_paraboloid.a() *
               (std::pow(cube[2][0], 3) - std::pow(cube[4][0], 3.0)) *
               (cube[2][1] - cube[4][1]) +
           aligned_paraboloid.b() * (cube[2][0] - cube[4][0]) *
               (std::pow(cube[2][1], 3) - std::pow(cube[4][1], 3.0)));

  auto segmented_half_edge = half_edge.generateSegmentedPolyhedron();
  Volume volume = intersectPolyhedronWithParaboloid<Volume>(
      &segmented_half_edge, &half_edge, aligned_paraboloid);

  EXPECT_NEAR(volume, expected_volume, 1.0e-15);
}

TEST(ParaboloidIntersection, Hang) {
  RectangularCuboid cube =
      RectangularCuboid::fromBoundingPts(Pt(0.0, 0.0, -1.0), Pt(1.0, 1.0, 2.0));
  ReferenceFrame frame(Normal(1.0, 0.0, 0.0), Normal(0.0, 1.0, 0.0),
                       Normal(0.0, 0.0, 1.0));

  AlignedParaboloid aligned_paraboloid;
  aligned_paraboloid.a() = -1.0;
  aligned_paraboloid.b() = -1.0;

  const double expected_volume = 0.125 * M_PI;

  HalfEdgePolyhedronParaboloid<Pt> half_edge;
  cube.setHalfEdgeVersion(&half_edge);
  auto seg_half_edge = half_edge.generateSegmentedPolyhedron();
  auto our_volume = intersectPolyhedronWithParaboloid<Volume>(
      &seg_half_edge, &half_edge, aligned_paraboloid);
  EXPECT_NEAR(our_volume, expected_volume, 1.0e-15);
}

TEST(ParaboloidIntersection, CornerIntersection) {
  RectangularCuboid cube =
      RectangularCuboid::fromBoundingPts(Pt(0.0, 0.0, -1.0), Pt(2.0, 2.0, 2.0));
  ReferenceFrame frame(Normal(1.0, 0.0, 0.0), Normal(0.0, 1.0, 0.0),
                       Normal(0.0, 0.0, 1.0));

  AlignedParaboloid aligned_paraboloid;
  aligned_paraboloid.a() = -1.0;
  aligned_paraboloid.b() = -1.0;

  const double expected_volume = 0.125 * M_PI;

  HalfEdgePolyhedronParaboloid<Pt> half_edge;
  cube.setHalfEdgeVersion(&half_edge);
  auto seg_half_edge = half_edge.generateSegmentedPolyhedron();
  auto our_volume = intersectPolyhedronWithParaboloid<Volume>(
      &seg_half_edge, &half_edge, aligned_paraboloid);
  EXPECT_NEAR(our_volume, expected_volume, 1.0e-15);
}

TEST(ParaboloidIntersection, EdgeIntersection) {
  RectangularCuboid cube = RectangularCuboid::fromBoundingPts(
      Pt(0.0, -2.0, -1.0), Pt(2.0, 2.0, 2.0));
  ReferenceFrame frame(Normal(1.0, 0.0, 0.0), Normal(0.0, 1.0, 0.0),
                       Normal(0.0, 0.0, 1.0));

  AlignedParaboloid aligned_paraboloid;
  aligned_paraboloid.a() = -1.0;
  aligned_paraboloid.b() = -1.0;

  const double expected_volume = 0.25 * M_PI;

  HalfEdgePolyhedronParaboloid<Pt> half_edge;
  cube.setHalfEdgeVersion(&half_edge);
  auto seg_half_edge = half_edge.generateSegmentedPolyhedron();
  auto our_volume = intersectPolyhedronWithParaboloid<Volume>(
      &seg_half_edge, &half_edge, aligned_paraboloid);
  EXPECT_NEAR(our_volume, expected_volume, 1.0e-15);
}

TEST(ParaboloidIntersection, EllipticUsedToSegFaultTriangulation) {
  RectangularCuboid cube = unit_cell;
  for (auto& pt : cube) {
    pt[0] += 7.840789842246486e-02;
    pt[1] += -6.018889214922042e-02;
    pt[2] += -2.872684750807761e-01;
  }
  HalfEdgePolyhedronParaboloid<Pt> half_edge;
  cube.setHalfEdgeVersion(&half_edge);

  AlignedParaboloid aligned_paraboloid;
  aligned_paraboloid.a() = -4.3641243694792;
  aligned_paraboloid.b() = -1.79756604529141;

  auto segmented_half_edge = half_edge.generateSegmentedPolyhedron();
  Volume volume = intersectPolyhedronWithParaboloid<Volume>(
      &segmented_half_edge, &half_edge, aligned_paraboloid);
}

TEST(ParaboloidIntersection, AvoidFaceOnlyIntegrationForImaginaryEllipse) {
  RectangularCuboid cube = unit_cell;

  ReferenceFrame frame(Normal(1.0, 0.0, 0.0), Normal(0.0, 1.0, 0.0),
                       Normal(0.0, 0.0, 1.0));
  double x_angle = 0.107166;
  double y_angle = 0.232923;
  double z_angle = 0.0;
  for (auto& pt : cube) {
    pt[0] += 0.0;
    pt[1] += 0.0;
    pt[2] += 0.0;
  }
  UnitQuaternion x_rotation(x_angle, frame[0]);
  UnitQuaternion y_rotation(y_angle, frame[1]);
  UnitQuaternion z_rotation(z_angle, frame[2]);
  frame = x_rotation * y_rotation * z_rotation * frame;
  for (auto& vertex : cube) {
    Pt tmp_pt = vertex;
    for (UnsignedIndex_t d = 0; d < 3; ++d) {
      vertex[d] = frame[d] * tmp_pt;
    }
  }

  HalfEdgePolyhedronParaboloid<Pt> half_edge;
  cube.setHalfEdgeVersion(&half_edge);

  AlignedParaboloid aligned_paraboloid;
  aligned_paraboloid.a() = -4.56485364034212;
  aligned_paraboloid.b() = -0.740918023473226;

  auto segmented_half_edge = half_edge.generateSegmentedPolyhedron();
  Volume volume = intersectPolyhedronWithParaboloid<Volume>(
      &segmented_half_edge, &half_edge, aligned_paraboloid);
  const double expected_volume = 1.920666789120243e-01;
  EXPECT_NEAR(volume, expected_volume, 1.0e-15);
}

TEST(ParaboloidIntersection, HyperbolicDoubleIntersect) {
  RectangularCuboid cube = unit_cell;
  for (auto& pt : cube) {
    pt[0] -= 0.0;
    pt[2] -= 0.3;
  }
  HalfEdgePolyhedronParaboloid<Pt> half_edge;
  cube.setHalfEdgeVersion(&half_edge);

  AlignedParaboloid aligned_paraboloid;
  aligned_paraboloid.a() = -16.0;
  aligned_paraboloid.b() = 1.0;

  auto segmented_half_edge = half_edge.generateSegmentedPolyhedron();
  Volume volume = intersectPolyhedronWithParaboloid<Volume>(
      &segmented_half_edge, &half_edge, aligned_paraboloid);
}

TEST(ParaboloidIntersection, OppositeArcIntersectionNoDoubleIntersect) {
  RectangularCuboid cube = unit_cell;

  ReferenceFrame frame(Normal(1.0, 0.0, 0.0), Normal(0.0, 1.0, 0.0),
                       Normal(0.0, 0.0, 1.0));
  double x_angle = 0.0;
  double y_angle = 0.0;
  double z_angle = 0.25 * M_PI;
  for (auto& pt : cube) {
    pt[0] += 0.0;
    pt[2] += 1.0;
  }
  UnitQuaternion x_rotation(x_angle, frame[0]);
  UnitQuaternion y_rotation(y_angle, frame[1]);
  UnitQuaternion z_rotation(z_angle, frame[2]);
  frame = x_rotation * y_rotation * z_rotation * frame;
  for (auto& vertex : cube) {
    Pt tmp_pt = vertex;
    for (UnsignedIndex_t d = 0; d < 3; ++d) {
      vertex[d] = frame[d] * tmp_pt;
    }
  }

  HalfEdgePolyhedronParaboloid<Pt> half_edge;
  cube.setHalfEdgeVersion(&half_edge);

  AlignedParaboloid aligned_paraboloid;
  aligned_paraboloid.a() = -16.0;
  aligned_paraboloid.b() = 24.0;

  auto segmented_half_edge = half_edge.generateSegmentedPolyhedron();
  Volume volume = intersectPolyhedronWithParaboloid<Volume>(
      &segmented_half_edge, &half_edge, aligned_paraboloid);
}  // namespace

TEST(ParaboloidIntersection, OppositeArcIntersectionNoAboveVertex) {
  RectangularCuboid cube = unit_cell;

  ReferenceFrame frame(Normal(1.0, 0.0, 0.0), Normal(0.0, 1.0, 0.0),
                       Normal(0.0, 0.0, 1.0));
  double x_angle = 0.0;
  double y_angle = 0.0;
  double z_angle = 0.0;
  for (auto& pt : cube) {
    pt[0] += 0.0;
    pt[2] += 1.0;
  }
  UnitQuaternion x_rotation(x_angle, frame[0]);
  UnitQuaternion y_rotation(y_angle, frame[1]);
  UnitQuaternion z_rotation(z_angle, frame[2]);
  frame = x_rotation * y_rotation * z_rotation * frame;
  for (auto& vertex : cube) {
    Pt tmp_pt = vertex;
    for (UnsignedIndex_t d = 0; d < 3; ++d) {
      vertex[d] = frame[d] * tmp_pt;
    }
  }

  HalfEdgePolyhedronParaboloid<Pt> half_edge;
  cube.setHalfEdgeVersion(&half_edge);

  AlignedParaboloid aligned_paraboloid;
  aligned_paraboloid.a() = -16.0;
  aligned_paraboloid.b() = 24.0;

  auto segmented_half_edge = half_edge.generateSegmentedPolyhedron();
  Volume volume = intersectPolyhedronWithParaboloid<Volume>(
      &segmented_half_edge, &half_edge, aligned_paraboloid);
}

TEST(ParaboloidIntersection,
     OppositeArcIntersectionOnlyPositiveDoubleIntersectBothFace) {
  RectangularCuboid cube = unit_cell;

  ReferenceFrame frame(Normal(1.0, 0.0, 0.0), Normal(0.0, 1.0, 0.0),
                       Normal(0.0, 0.0, 1.0));
  double x_angle = 0.0;
  double y_angle = 0.0;
  double z_angle = 0.0;
  for (auto& pt : cube) {
    pt[0] += 0.0;
    pt[2] += -1.0;
  }
  UnitQuaternion x_rotation(x_angle, frame[0]);
  UnitQuaternion y_rotation(y_angle, frame[1]);
  UnitQuaternion z_rotation(z_angle, frame[2]);
  frame = x_rotation * y_rotation * z_rotation * frame;
  for (auto& vertex : cube) {
    Pt tmp_pt = vertex;
    for (UnsignedIndex_t d = 0; d < 3; ++d) {
      vertex[d] = frame[d] * tmp_pt;
    }
  }

  HalfEdgePolyhedronParaboloid<Pt> half_edge;
  cube.setHalfEdgeVersion(&half_edge);

  AlignedParaboloid aligned_paraboloid;
  aligned_paraboloid.a() = -40.0;
  aligned_paraboloid.b() = 100.0;

  auto segmented_half_edge = half_edge.generateSegmentedPolyhedron();
  Volume volume = intersectPolyhedronWithParaboloid<Volume>(
      &segmented_half_edge, &half_edge, aligned_paraboloid);
}

TEST(ParaboloidIntersection, ZeroLengthDoubleIntersection) {
  RectangularCuboid cube = unit_cell;
  for (auto& pt : cube) {
    pt[0] -= 0.5;
    pt[2] -= 0.3;
  }
  HalfEdgePolyhedronParaboloid<Pt> half_edge;
  cube.setHalfEdgeVersion(&half_edge);

  AlignedParaboloid aligned_paraboloid;
  aligned_paraboloid.a() = -2.0;
  aligned_paraboloid.b() = 1.0;

  auto segmented_half_edge = half_edge.generateSegmentedPolyhedron();
  Volume volume = intersectPolyhedronWithParaboloid<Volume>(
      &segmented_half_edge, &half_edge, aligned_paraboloid);
}

// TEST(ParaboloidIntersection, HyperbolicSaddleOnFace) {
//   RectangularCuboid cube = unit_cell;
//   for (auto& pt : cube) {
//     pt[2] -= 0.5;
//   }
//   HalfEdgePolyhedronParaboloid<Pt> half_edge;
//   cube.setHalfEdgeVersion(&half_edge);

//   AlignedParaboloid aligned_paraboloid;
//   aligned_paraboloid.a() = -8.0;
//   aligned_paraboloid.b() = 1.0;

//   auto segmented_half_edge = half_edge.generateSegmentedPolyhedron();
//   Volume volume = intersectPolyhedronWithParaboloid<Volume>(
//       &segmented_half_edge, &half_edge, aligned_paraboloid);
// }

TEST(ParaboloidIntersection, FaceCheckEdgeIntersection) {
  auto test_pt =
      std::array<double, 2>{{0.0627407957620372, -1.7483272918056e-17}};
  auto vertex_0 = Pt(0.0716003162323803, 0.707044018770285, -0.494936511318966);
  auto vertex_1 =
      Pt(0.763795083150914, -0.00942101486918973, -0.408078810321392);
  bool intersect = isPtBeforeIntersectionWithEdge(test_pt, vertex_0, vertex_1);
  EXPECT_EQ(intersect, true);
}

TEST(ParaboloidIntersection, HyperbolicDoublePositiveIntersectionOnFaceOnly) {
  RectangularCuboid cube = unit_cell;

  ReferenceFrame frame(Normal(1.0, 0.0, 0.0), Normal(0.0, 1.0, 0.0),
                       Normal(0.0, 0.0, 1.0));
  double x_angle = 1.905267446341692e-01;
  double y_angle = -1.097275760037612e+00;
  double z_angle = 0.0;
  UnitQuaternion x_rotation(x_angle, frame[0]);
  UnitQuaternion y_rotation(y_angle, frame[1]);
  UnitQuaternion z_rotation(z_angle, frame[2]);
  Pt translation(4.349467192451266e-01, 2.202268815643906e-01,
                 -1.422857315239455e-01);
  frame = x_rotation * y_rotation * z_rotation * frame;
  for (auto& vertex : cube) {
    Pt tmp_pt = vertex;
    for (UnsignedIndex_t d = 0; d < 3; ++d) {
      vertex[d] = frame[d] * tmp_pt;
    }
    vertex += translation;
  }

  HalfEdgePolyhedronParaboloid<Pt> half_edge;
  cube.setHalfEdgeVersion(&half_edge);

  AlignedParaboloid aligned_paraboloid;
  aligned_paraboloid.a() = -4.322181905576079e+00;
  aligned_paraboloid.b() = 1.767768544145609e+00;

  auto segmented_half_edge = half_edge.generateSegmentedPolyhedron();
  Volume volume = intersectPolyhedronWithParaboloid<Volume>(
      &segmented_half_edge, &half_edge, aligned_paraboloid);
}

TEST(ParaboloidIntersection, HyperbolicEdgeWithOutsideArc) {
  RectangularCuboid cube = unit_cell;

  ReferenceFrame frame(Normal(1.0, 0.0, 0.0), Normal(0.0, 1.0, 0.0),
                       Normal(0.0, 0.0, 1.0));
  double x_angle = -1.090102821218185e+00;
  double y_angle = -3.303341475471961e-01;
  double z_angle = 0.0;
  UnitQuaternion x_rotation(x_angle, frame[0]);
  UnitQuaternion y_rotation(y_angle, frame[1]);
  UnitQuaternion z_rotation(z_angle, frame[2]);
  Pt translation(-4.263946428622598e-01, -2.222543190855016e-01,
                 -3.692489951019640e-01);
  frame = x_rotation * y_rotation * z_rotation * frame;
  for (auto& vertex : cube) {
    Pt tmp_pt = vertex;
    for (UnsignedIndex_t d = 0; d < 3; ++d) {
      vertex[d] = frame[d] * tmp_pt;
    }
    vertex += translation;
  }

  HalfEdgePolyhedronParaboloid<Pt> half_edge;
  cube.setHalfEdgeVersion(&half_edge);

  AlignedParaboloid aligned_paraboloid;
  aligned_paraboloid.a() = -8.041744087190326e-01;
  aligned_paraboloid.b() = 3.682416737481792e+00;

  auto segmented_half_edge = half_edge.generateSegmentedPolyhedron();
  Volume volume = intersectPolyhedronWithParaboloid<Volume>(
      &segmented_half_edge, &half_edge, aligned_paraboloid);

  // Answer from AMR integration
  const double expected_volume = 8.545338138236155e-01;
  EXPECT_NEAR(volume, expected_volume, 1.0e-15);
}

TEST(ParaboloidIntersection, HyperbolicSplitIntoTwoPoly) {
  RectangularCuboid cube = unit_cell;

  ReferenceFrame frame(Normal(1.0, 0.0, 0.0), Normal(0.0, 1.0, 0.0),
                       Normal(0.0, 0.0, 1.0));
  double x_angle = 1.354616967639307e+00;
  double y_angle = -1.224415715485103e-01;
  double z_angle = 0.0;
  UnitQuaternion x_rotation(x_angle, frame[0]);
  UnitQuaternion y_rotation(y_angle, frame[1]);
  UnitQuaternion z_rotation(z_angle, frame[2]);
  Pt translation(1.825798345077093e-01, -3.213967486370281e-01,
                 -1.086782810143829e-01);
  frame = x_rotation * y_rotation * z_rotation * frame;
  for (auto& vertex : cube) {
    Pt tmp_pt = vertex;
    for (UnsignedIndex_t d = 0; d < 3; ++d) {
      vertex[d] = frame[d] * tmp_pt;
    }
    vertex += translation;
  }

  HalfEdgePolyhedronParaboloid<Pt> half_edge;
  cube.setHalfEdgeVersion(&half_edge);

  AlignedParaboloid aligned_paraboloid;
  aligned_paraboloid.a() = -3.783506526398717e+00;
  aligned_paraboloid.b() = 4.873164333373181e+00;

  auto segmented_half_edge = half_edge.generateSegmentedPolyhedron();
  Volume volume = intersectPolyhedronWithParaboloid<Volume>(
      &segmented_half_edge, &half_edge, aligned_paraboloid);

  // Answer from AMR integration
  const double expected_volume = 6.664597269536864e-01;
  EXPECT_NEAR(volume, expected_volume, 1.0e-15);
}

TEST(ParaboloidIntersection, HyperbolicOppositeNappeEdge) {
  RectangularCuboid cube = unit_cell;

  ReferenceFrame frame(Normal(1.0, 0.0, 0.0), Normal(0.0, 1.0, 0.0),
                       Normal(0.0, 0.0, 1.0));
  double x_angle = -1.235875691970824e+00;
  double y_angle = 5.631558898260325e-01;
  double z_angle = 0.0;
  UnitQuaternion x_rotation(x_angle, frame[0]);
  UnitQuaternion y_rotation(y_angle, frame[1]);
  UnitQuaternion z_rotation(z_angle, frame[2]);
  Pt translation(-2.685242849836422e-01, 4.501006485325034e-01,
                 -4.725286007977103e-01);
  frame = x_rotation * y_rotation * z_rotation * frame;
  for (auto& vertex : cube) {
    Pt tmp_pt = vertex;
    for (UnsignedIndex_t d = 0; d < 3; ++d) {
      vertex[d] = frame[d] * tmp_pt;
    }
    vertex += translation;
  }

  HalfEdgePolyhedronParaboloid<Pt> half_edge;
  cube.setHalfEdgeVersion(&half_edge);

  AlignedParaboloid aligned_paraboloid;
  aligned_paraboloid.a() = -4.252597083964816e+00;
  aligned_paraboloid.b() = 8.299887711888987e-01;

  auto segmented_half_edge = half_edge.generateSegmentedPolyhedron();
  Volume volume = intersectPolyhedronWithParaboloid<Volume>(
      &segmented_half_edge, &half_edge, aligned_paraboloid);
}

TEST(ParaboloidIntersection, HyperbolicDoublePositiveIntersect) {
  RectangularCuboid cube = unit_cell;

  ReferenceFrame frame(Normal(1.0, 0.0, 0.0), Normal(0.0, 1.0, 0.0),
                       Normal(0.0, 0.0, 1.0));
  double x_angle = 0.0;
  double y_angle = 0.0;
  double z_angle = 0.0;
  UnitQuaternion x_rotation(x_angle, frame[0]);
  UnitQuaternion y_rotation(y_angle, frame[1]);
  UnitQuaternion z_rotation(z_angle, frame[2]);
  Pt translation(0.0, 0.0, 0.0);
  frame = x_rotation * y_rotation * z_rotation * frame;
  for (auto& vertex : cube) {
    Pt tmp_pt = vertex;
    for (UnsignedIndex_t d = 0; d < 3; ++d) {
      vertex[d] = frame[d] * tmp_pt;
    }
    vertex += translation;
  }

  HalfEdgePolyhedronParaboloid<Pt> half_edge;
  cube.setHalfEdgeVersion(&half_edge);

  AlignedParaboloid aligned_paraboloid;
  aligned_paraboloid.a() = -1.0e-5;
  aligned_paraboloid.b() = 4.0;

  auto segmented_half_edge = half_edge.generateSegmentedPolyhedron();
  Volume volume = intersectPolyhedronWithParaboloid<Volume>(
      &segmented_half_edge, &half_edge, aligned_paraboloid);
}

TEST(ParaboloidIntersection, HyperbolicFailure) {
  AlignedParaboloid aligned_paraboloid;
  ReferenceFrame frame(Normal(1.0, 0.0, 0.0), Normal(0.0, 1.0, 0.0),
                       Normal(0.0, 0.0, 1.0));
  RectangularCuboid cube = unit_cell;
  aligned_paraboloid.a() = -3.255549036673901e+00;
  aligned_paraboloid.b() = 3.915121588147700e+00;
  std::array<double, 3> angles;
  std::array<double, 3> translations;
  angles[0] = 1.250976829396032e+00;
  angles[1] = 1.313537905443374e-01;
  angles[2] = 0.000000000000000e+00;
  translations[0] = 4.443715139224169e-01;
  translations[1] = 4.853842404708342e-02;
  translations[2] = -4.618329341547773e-01;
  UnitQuaternion x_rotation(angles[0], frame[0]);
  UnitQuaternion y_rotation(angles[1], frame[1]);
  frame = x_rotation * y_rotation * frame;
  for (auto& vertex : cube) {
    Pt tmp_pt = vertex;
    for (UnsignedIndex_t d = 0; d < 3; ++d) {
      vertex[d] = frame[d] * tmp_pt;
      vertex[d] += translations[d];
    }
  }

  HalfEdgePolyhedronParaboloid<Pt> half_edge;
  cube.setHalfEdgeVersion(&half_edge);
  auto seg_half_edge = half_edge.generateSegmentedPolyhedron();
  auto our_volume = intersectPolyhedronWithParaboloid<Volume>(
      &seg_half_edge, &half_edge, aligned_paraboloid);

  const double expected_volume = 5.280775350506421e-01;
  EXPECT_NEAR(our_volume, expected_volume, 1.0e-15);
}

TEST(ParaboloidIntersection, Dodecahedron) {
  double tau = (sqrt(5.0) + 1.0) / 2.0;
  Pt M[12] = {Pt(0, tau, 1),       Pt(0.0, -tau, 1.0),  Pt(0.0, tau, -1.0),
              Pt(0.0, -tau, -1.0), Pt(1.0, 0.0, tau),   Pt(-1.0, 0.0, tau),
              Pt(1.0, 0.0, -tau),  Pt(-1.0, 0.0, -tau), Pt(tau, 1.0, 0.0),
              Pt(-tau, 1.0, 0.0),  Pt(tau, -1.0, 0.0),  Pt(-tau, -1.0, 0.0)};
  std::array<Pt, 20> vertex_list{{(1.0 / 3.0) * (M[0] + M[8] + M[2]),
                                  (1.0 / 3.0) * (M[0] + M[4] + M[8]),
                                  (1.0 / 3.0) * (M[0] + M[5] + M[4]),
                                  (1.0 / 3.0) * (M[0] + M[9] + M[5]),
                                  (1.0 / 3.0) * (M[0] + M[2] + M[9]),
                                  (1.0 / 3.0) * (M[2] + M[8] + M[6]),
                                  (1.0 / 3.0) * (M[8] + M[10] + M[6]),
                                  (1.0 / 3.0) * (M[8] + M[4] + M[10]),
                                  (1.0 / 3.0) * (M[4] + M[1] + M[10]),
                                  (1.0 / 3.0) * (M[4] + M[5] + M[1]),
                                  (1.0 / 3.0) * (M[5] + M[11] + M[1]),
                                  (1.0 / 3.0) * (M[5] + M[9] + M[11]),
                                  (1.0 / 3.0) * (M[9] + M[7] + M[11]),
                                  (1.0 / 3.0) * (M[9] + M[2] + M[7]),
                                  (1.0 / 3.0) * (M[2] + M[6] + M[7]),
                                  (1.0 / 3.0) * (M[3] + M[10] + M[1]),
                                  (1.0 / 3.0) * (M[3] + M[1] + M[11]),
                                  (1.0 / 3.0) * (M[3] + M[11] + M[7]),
                                  (1.0 / 3.0) * (M[3] + M[7] + M[6]),
                                  (1.0 / 3.0) * (M[3] + M[6] + M[10])}};

  std::array<std::array<UnsignedIndex_t, 5>, 12> face_mapping{
      {{5, 4, 3, 2, 1},
       {1, 2, 8, 7, 6},
       {2, 3, 10, 9, 8},
       {3, 4, 12, 11, 10},
       {4, 5, 14, 13, 12},
       {5, 1, 6, 15, 14},
       {16, 17, 18, 19, 20},
       {16, 20, 7, 8, 9},
       {9, 10, 11, 17, 16},
       {11, 12, 13, 18, 17},
       {6, 7, 20, 19, 15},
       {13, 14, 15, 19, 18}}};

  for (int i = 0; i < 12; i++)
    for (int j = 0; j < 5; j++) face_mapping[i][j]--;

  double scale = 0.5;
  for (int i = 0; i < 20; i++) vertex_list[i] *= scale;

  int Ntests = 100;
  double max_error = 0.0, rms_error = 0.0;
  bool first_vertex_on_surface = false;
  HalfEdgePolyhedronParaboloid<Pt> half_edge;
  // Rotate cube
  std::random_device
      rd;  // Get a random seed from the OS entropy device, or whatever
  std::mt19937_64 eng(rd());  // Use the 64-bit Mersenne Twister 19937
                              // generator and seed it with entropy.
  static const int ncycles = 1;
  std::uniform_real_distribution<double> random_rotation(-0.5 * M_PI,
                                                         0.5 * M_PI);
  std::uniform_real_distribution<double> random_coeffs_a(-5.0, 5.0);
  std::uniform_real_distribution<double> random_coeffs_b(-5.0, 5.0);
  std::uniform_real_distribution<double> random_translation(-0.5, 0.5);

  for (int i = 0; i < Ntests; i++) {
    PolyhedronConnectivity connectivity(face_mapping);
    GeneralPolyhedron dodeca(vertex_list, &connectivity);
    AlignedParaboloid aligned_paraboloid;
    ReferenceFrame frame(Normal(1.0, 0.0, 0.0), Normal(0.0, 1.0, 0.0),
                         Normal(0.0, 0.0, 1.0));
    double angles[3] = {random_rotation(eng), random_rotation(eng), 0.0};
    Pt translations(random_translation(eng), random_translation(eng),
                    random_translation(eng));
    aligned_paraboloid.a() = random_coeffs_a(eng);
    aligned_paraboloid.b() = random_coeffs_b(eng);

    // aligned_paraboloid.a() = -1.4077378333274168654;
    // aligned_paraboloid.b() = -3.8824479920417851453;
    // angles[0] = 0.71624477503652372867;
    // angles[1] = 0.15892377522170786364;
    // angles[2] = -1.4763614058087308756;
    // translations[0] = 0.4483991440918613236;
    // translations[1] = -0.16719239417173020756;
    // translations[2] = 0.3516101636110545714;

    std::cout << "-------------------------------------------------------------"
                 "---------------------------------------------------------"
              << std::endl;
    std::cout << "Case setup." << std::endl;
    std::cout << "-------------------------------------------------------------"
                 "---------------------------------------------------------"
              << std::endl;

    std::cout << std::setprecision(20)
              << "aligned_paraboloid.a() = " << aligned_paraboloid.a() << ";"
              << std::endl;
    std::cout << std::setprecision(20)
              << "aligned_paraboloid.b() = " << aligned_paraboloid.b() << ";"
              << std::endl;
    std::cout << std::setprecision(20) << "angles[0] = " << angles[0] << ";"
              << std::endl;
    std::cout << std::setprecision(20) << "angles[1] = " << angles[1] << ";"
              << std::endl;
    std::cout << std::setprecision(20) << "angles[2] = " << angles[2] << ";"
              << std::endl;
    std::cout << std::setprecision(20)
              << "translations[0] = " << translations[0] << ";" << std::endl;
    std::cout << std::setprecision(20)
              << "translations[1] = " << translations[1] << ";" << std::endl;
    std::cout << std::setprecision(20)
              << "translations[2] = " << translations[2] << ";" << std::endl;

    if (first_vertex_on_surface) translations[2] = 0.0;

    UnitQuaternion x_rotation(angles[0], frame[0]);
    UnitQuaternion y_rotation(angles[1], frame[1]);
    UnitQuaternion z_rotation(angles[2], frame[2]);
    frame = x_rotation * y_rotation * z_rotation * frame;
    for (auto& vertex : dodeca) {
      Pt tmp_pt = vertex + translations;
      for (UnsignedIndex_t d = 0; d < 3; ++d) {
        vertex[d] = frame[d] * tmp_pt;
      }
    }

    double local_space_translation = 0.0;
    if (first_vertex_on_surface) {
      for (auto& vertex : dodeca) {
        Pt tmp_pt = vertex;
        local_space_translation =
            -aligned_paraboloid.a() * vertex[0] * vertex[0] -
            aligned_paraboloid.b() * vertex[1] * vertex[1] - vertex[2];
        break;
      }
      for (auto& vertex : dodeca) {
        vertex[2] += local_space_translation;
      }
    }
    translations += local_space_translation * frame[2];

    std::cout << "-------------------------------------------------------------"
                 "---------------------------------------------------------"
              << std::endl;
    std::cout << "IRL volume computation." << std::endl;
    std::cout << "-------------------------------------------------------------"
                 "---------------------------------------------------------"
              << std::endl;
    dodeca.setHalfEdgeVersion(&half_edge);
    auto seg_half_edge = half_edge.generateSegmentedPolyhedron();
    std::cout << seg_half_edge << std::endl;

    for (auto& face : seg_half_edge) {
      auto normal = Normal(0.0, 0.0, 0.0);
      const auto starting_half_edge = face->getStartingHalfEdge();
      auto current_half_edge = starting_half_edge;
      auto next_half_edge = starting_half_edge->getNextHalfEdge();
      const auto& start_location =
          starting_half_edge->getPreviousVertex()->getLocation();
      do {
        normal += crossProduct(
            current_half_edge->getVertex()->getLocation() - start_location,
            next_half_edge->getVertex()->getLocation() - start_location);
        current_half_edge = next_half_edge;
        next_half_edge = next_half_edge->getNextHalfEdge();
      } while (next_half_edge != starting_half_edge);
      normal.normalize();
      face->setPlane(Plane(normal, normal * start_location));
    }

    auto poly_vol = seg_half_edge.calculateVolume();
    auto amr_volume = intersectPolyhedronWithParaboloidAMR<Volume>(
        &seg_half_edge, &half_edge, aligned_paraboloid, 17);
    auto our_volume = intersectPolyhedronWithParaboloid<Volume>(
        &seg_half_edge, &half_edge, aligned_paraboloid);
    std::cout << "-------------------------------------------------------------"
                 "---------------------------------------------------------"
              << std::endl;
    std::cout << "Test " << i + 1 << "/" << Ntests << std::endl;
    // error = fabs(our_volume - moments[0]);
    if (aligned_paraboloid.a() * aligned_paraboloid.b() > 0.0)
      std::cout << "ELLIPTIC" << std::endl;
    else if (aligned_paraboloid.a() * aligned_paraboloid.b() < 0.0)
      std::cout << "HYPERBOLIC" << std::endl;
    else
      std::cout << "PARABOLIC" << std::endl;
    // std::cout << std::setprecision(20) << "Volume polyhedron = " << poly_vol
    //           << std::endl;
    std::cout << std::setprecision(20)
              << "Vfrac unclipped IRL = " << our_volume / poly_vol << std::endl;
    std::cout << std::setprecision(20)
              << "Vfrac unclipped AMR = " << amr_volume / poly_vol << std::endl;
    std::cout << "Diff AMR/IRL = " << fabs(our_volume - amr_volume) / poly_vol
              << std::endl;
    std::cout << "-------------------------------------------------------------"
                 "---------------------------------------------------------"
              << std::endl;

    max_error = max_error > fabs(our_volume - amr_volume) / poly_vol
                    ? max_error
                    : fabs(our_volume - amr_volume) / poly_vol;
    rms_error += fabs(our_volume - amr_volume) * fabs(our_volume - amr_volume) /
                 poly_vol / poly_vol;

    if (fabs(our_volume - amr_volume) / poly_vol > 1.0e-10) exit(1);
  }
  rms_error = sqrt(rms_error / static_cast<double>(Ntests));

  std::cout << "Max error = " << max_error << std::endl;
  std::cout << "RMS error = " << rms_error << std::endl;
  std::cout << "-------------------------------------------------------------"
               "---------------------------------------------------------"
            << std::endl;

  EXPECT_NEAR(max_error, 0.0, 1.0e-13);
}

TEST(ParaboloidIntersection, RationalBezierArc) {
  const auto pt_0 = Pt(0.0, 0.0, 0.0);
  const auto pt_c = Pt(1.0, 1.0, 1.0);
  const auto pt_1 = Pt(2.0, 2.0, 2.0);
  const double weight = 1.0;

  std::cout << "Start point address = "
            << reinterpret_cast<std::uintptr_t>(&pt_0) << " -- value = " << pt_0
            << std::endl;
  std::cout << "Control point address = "
            << reinterpret_cast<std::uintptr_t>(&pt_c) << " -- value = " << pt_c
            << std::endl;
  std::cout << "End point address = " << reinterpret_cast<std::uintptr_t>(&pt_1)
            << " -- value = " << pt_1 << std::endl;

  auto arc = RationalBezierArc(pt_0, pt_c, pt_1, weight);
  std::cout << "Rational Bezier arc = " << arc << std::endl;
}

TEST(ParaboloidIntersection, ParametrizedSurface) {
  const auto pt_0 = Pt(0.0, 0.0, 0.0);
  const auto pt_c = Pt(1.0, 1.0, 1.0);
  const auto pt_1 = Pt(2.0, 2.0, 2.0);
  const double weight = 1.0;

  auto arc0 = RationalBezierArc(pt_0, pt_c, pt_1, weight);
  auto arc1 = RationalBezierArc(pt_1, pt_0, pt_c, weight);
  auto arc2 = RationalBezierArc(pt_c, pt_1, pt_0, weight);

  std::cout << "Rational Bezier arc0 = " << arc0 << std::endl;
  std::cout << "Rational Bezier arc1 = " << arc1 << std::endl;
  std::cout << "Rational Bezier arc2 = " << arc2 << std::endl;

  ReferenceFrame frame(Normal(1.0, 0.0, 0.0), Normal(0.0, 1.0, 0.0),
                       Normal(0.0, 0.0, 1.0));

  Pt datum(0.0, 0.0, 0.0);
  Paraboloid paraboloid(datum, frame, 1.0, -1.0);

  ParametrizedSurfaceOutput surface(paraboloid);
  surface.addArc(arc0);
  surface.addArc(arc1);
  surface.addArc(arc2);
  std::cout << "\n\nParametrized surface = " << surface << std::endl;

  surface.clearArcs();
  std::cout << "\n\nParametrized surface after clear = " << surface
            << std::endl;
}

TEST(ParaboloidIntersection, DodecahedronWithSurface) {
  double tau = (sqrt(5.0) + 1.0) / 2.0;
  Pt M[12] = {Pt(0.0, tau, 1.0),   Pt(0.0, -tau, 1.0),  Pt(0.0, tau, -1.0),
              Pt(0.0, -tau, -1.0), Pt(1.0, 0.0, tau),   Pt(-1.0, 0.0, tau),
              Pt(1.0, 0.0, -tau),  Pt(-1.0, 0.0, -tau), Pt(tau, 1.0, 0.0),
              Pt(-tau, 1.0, 0.0),  Pt(tau, -1.0, 0.0),  Pt(-tau, -1.0, 0.0)};
  std::array<Pt, 20> vertex_list{{(1.0 / 3.0) * (M[0] + M[8] + M[2]),
                                  (1.0 / 3.0) * (M[0] + M[4] + M[8]),
                                  (1.0 / 3.0) * (M[0] + M[5] + M[4]),
                                  (1.0 / 3.0) * (M[0] + M[9] + M[5]),
                                  (1.0 / 3.0) * (M[0] + M[2] + M[9]),
                                  (1.0 / 3.0) * (M[2] + M[8] + M[6]),
                                  (1.0 / 3.0) * (M[8] + M[10] + M[6]),
                                  (1.0 / 3.0) * (M[8] + M[4] + M[10]),
                                  (1.0 / 3.0) * (M[4] + M[1] + M[10]),
                                  (1.0 / 3.0) * (M[4] + M[5] + M[1]),
                                  (1.0 / 3.0) * (M[5] + M[11] + M[1]),
                                  (1.0 / 3.0) * (M[5] + M[9] + M[11]),
                                  (1.0 / 3.0) * (M[9] + M[7] + M[11]),
                                  (1.0 / 3.0) * (M[9] + M[2] + M[7]),
                                  (1.0 / 3.0) * (M[2] + M[6] + M[7]),
                                  (1.0 / 3.0) * (M[3] + M[10] + M[1]),
                                  (1.0 / 3.0) * (M[3] + M[1] + M[11]),
                                  (1.0 / 3.0) * (M[3] + M[11] + M[7]),
                                  (1.0 / 3.0) * (M[3] + M[7] + M[6]),
                                  (1.0 / 3.0) * (M[3] + M[6] + M[10])}};

  std::array<std::array<UnsignedIndex_t, 5>, 12> face_mapping{
      {{5, 4, 3, 2, 1},
       {1, 2, 8, 7, 6},
       {2, 3, 10, 9, 8},
       {3, 4, 12, 11, 10},
       {4, 5, 14, 13, 12},
       {5, 1, 6, 15, 14},
       {16, 17, 18, 19, 20},
       {16, 20, 7, 8, 9},
       {9, 10, 11, 17, 16},
       {11, 12, 13, 18, 17},
       {6, 7, 20, 19, 15},
       {13, 14, 15, 19, 18}}};

  for (int i = 0; i < 12; i++)
    for (int j = 0; j < 5; j++) face_mapping[i][j]--;

  double scale = 0.5;
  for (int i = 0; i < 20; i++) vertex_list[i] *= scale;

  int Ntests = 1;
  double max_error = 0.0, rms_error = 0.0;
  bool first_vertex_on_surface = false;
  HalfEdgePolyhedronParaboloid<Pt> half_edge;
  // Rotate cube
  std::random_device
      rd;  // Get a random seed from the OS entropy device, or whatever
  std::mt19937_64 eng(rd());  // Use the 64-bit Mersenne Twister 19937
                              // generator and seed it with entropy.
  static const int ncycles = 1;
  std::uniform_real_distribution<double> random_rotation(-0.5 * M_PI,
                                                         0.5 * M_PI);
  std::uniform_real_distribution<double> random_coeffs_a(-5.0, 5.0);
  std::uniform_real_distribution<double> random_coeffs_b(-5.0, 5.0);
  std::uniform_real_distribution<double> random_translation(-0.5, 0.5);

  for (int i = 0; i < Ntests; i++) {
    PolyhedronConnectivity connectivity(face_mapping);
    GeneralPolyhedron dodeca(vertex_list, &connectivity);
    auto dodeca_unrotated = dodeca;
    AlignedParaboloid aligned_paraboloid;
    ReferenceFrame orig_frame(Normal(1.0, 0.0, 0.0), Normal(0.0, 1.0, 0.0),
                              Normal(0.0, 0.0, 1.0));
    double angles[3] = {random_rotation(eng), random_rotation(eng), 0.0};
    Pt translations(random_translation(eng), random_translation(eng),
                    random_translation(eng));
    aligned_paraboloid.a() = random_coeffs_a(eng);
    aligned_paraboloid.b() = random_coeffs_b(eng);

    // aligned_paraboloid.a() = 3.6157030206049824983;
    // aligned_paraboloid.b() = 4.1295193652799984108;
    // angles[0] = -0.97868152343085124123;
    // angles[1] = -0.57539771632986991268;
    // angles[2] = 0;
    // translations[0] = -0.43414184358285634602;
    // translations[1] = 0.28645929816099324761;
    // translations[2] = -0.086163975224342714831;

    // aligned_paraboloid.a() = 10.0;
    // aligned_paraboloid.b() = 10.0;
    // angles[0] = M_PI / 10.0;
    // angles[1] = 0.0;
    // angles[2] = 0.0;
    // translations[0] = 0.2;
    // translations[1] = 0.02;
    // translations[2] = 0.45;

    // aligned_paraboloid.a() = -10.0;
    // aligned_paraboloid.b() = -10.0;
    // angles[0] = M_PI / 10.0;
    // angles[1] = 0.0;
    // angles[2] = 0.0;
    // translations[0] = 0.2;
    // translations[1] = 0.02;
    // translations[2] = -0.45;

    aligned_paraboloid.a() = 0.5;
    aligned_paraboloid.b() = -0.5;
    angles[0] = M_PI / 10.0;
    angles[1] = M_PI / 10.0;
    angles[2] = 0;
    translations[0] = 0.0;
    translations[1] = 0.0;
    translations[2] = 0.0;

    std::cout << "-------------------------------------------------------------"
                 "---------------------------------------------------------"
              << std::endl;
    std::cout << "Case setup." << std::endl;
    std::cout << "-------------------------------------------------------------"
                 "---------------------------------------------------------"
              << std::endl;

    std::cout << std::setprecision(20)
              << "aligned_paraboloid.a() = " << aligned_paraboloid.a() << ";"
              << std::endl;
    std::cout << std::setprecision(20)
              << "aligned_paraboloid.b() = " << aligned_paraboloid.b() << ";"
              << std::endl;
    std::cout << std::setprecision(20) << "angles[0] = " << angles[0] << ";"
              << std::endl;
    std::cout << std::setprecision(20) << "angles[1] = " << angles[1] << ";"
              << std::endl;
    std::cout << std::setprecision(20) << "angles[2] = " << angles[2] << ";"
              << std::endl;
    std::cout << std::setprecision(20)
              << "translations[0] = " << translations[0] << ";" << std::endl;
    std::cout << std::setprecision(20)
              << "translations[1] = " << translations[1] << ";" << std::endl;
    std::cout << std::setprecision(20)
              << "translations[2] = " << translations[2] << ";" << std::endl;

    if (first_vertex_on_surface) translations[2] = 0.0;

    auto frame = orig_frame;
    UnitQuaternion x_rotation(angles[0], frame[0]);
    UnitQuaternion y_rotation(angles[1], frame[1]);
    UnitQuaternion z_rotation(angles[2], frame[2]);
    frame = x_rotation * y_rotation * z_rotation * frame;
    for (auto& vertex : dodeca) {
      Pt tmp_pt = vertex + translations;
      for (UnsignedIndex_t d = 0; d < 3; ++d) {
        vertex[d] = frame[d] * tmp_pt;
      }
    }

    double local_space_translation = 0.0;
    if (first_vertex_on_surface) {
      for (auto& vertex : dodeca) {
        Pt tmp_pt = vertex;
        local_space_translation =
            -aligned_paraboloid.a() * vertex[0] * vertex[0] -
            aligned_paraboloid.b() * vertex[1] * vertex[1] - vertex[2];
        break;
      }
      for (auto& vertex : dodeca) {
        vertex[2] += local_space_translation;
      }
    }
    translations += local_space_translation * frame[2];

    std::cout << "-------------------------------------------------------------"
                 "---------------------------------------------------------"
              << std::endl;
    std::cout << "IRL volume computation." << std::endl;
    std::cout << "-------------------------------------------------------------"
                 "---------------------------------------------------------"
              << std::endl;
    std::string poly_filename = "cell_" + std::to_string(i);
    std::string surf_filename = "surface_" + std::to_string(i);
    dodeca.setHalfEdgeVersion(&half_edge);
    auto seg_half_edge = half_edge.generateSegmentedPolyhedron();
    auto poly_vol = seg_half_edge.calculateVolume();

    for (auto& face : seg_half_edge) {
      auto normal = Normal(0.0, 0.0, 0.0);
      const auto starting_half_edge = face->getStartingHalfEdge();
      auto current_half_edge = starting_half_edge;
      auto next_half_edge = starting_half_edge->getNextHalfEdge();
      const auto& start_location =
          starting_half_edge->getPreviousVertex()->getLocation();
      do {
        normal += crossProduct(
            current_half_edge->getVertex()->getLocation() - start_location,
            next_half_edge->getVertex()->getLocation() - start_location);
        current_half_edge = next_half_edge;
        next_half_edge = next_half_edge->getNextHalfEdge();
      } while (next_half_edge != starting_half_edge);
      normal.normalize();
      face->setPlane(Plane(normal, normal * start_location));
    }

    Paraboloid paraboloid(-translations, frame, aligned_paraboloid.a(),
                          aligned_paraboloid.b());

    auto amr_volume_dummy = intersectPolyhedronWithParaboloidAMR<Volume>(
        &seg_half_edge, &half_edge, aligned_paraboloid, 10,
        poly_filename);  // This prints the AMR triangles
    auto amr_moments = intersectPolyhedronWithParaboloidAMR<VolumeMoments>(
        &seg_half_edge, &half_edge, aligned_paraboloid, 17);
    // Move centroid to global reference frame
    auto centroid = IRL::Pt(0.0, 0.0, 0.0);
    for (std::size_t d = 0; d < 3; ++d) {
      for (std::size_t n = 0; n < 3; ++n) {
        centroid[n] += frame[d][n] * amr_moments.centroid()[d];
      }
    }
    centroid -= amr_moments.volume() * translations;
    amr_moments.centroid() = centroid;

    ParametrizedSurfaceOutput surface(
        Paraboloid(Pt(0.0, 0.0, 0.0),
                   ReferenceFrame(Normal(1.0, 0.0, 0.0), Normal(0.0, 1.0, 0.0),
                                  Normal(0.0, 0.0, 1.0)),
                   aligned_paraboloid.a(), aligned_paraboloid.b()));
    auto our_moments = intersectPolyhedronWithParaboloid<VolumeMoments>(
        &seg_half_edge, &half_edge, aligned_paraboloid, &surface);
    // auto volume_and_surface = getVolumeMoments<
    //     AddSurfaceOutput<VolumeMoments, ParametrizedSurfaceOutput>,
    //     HalfEdgeCutting>(dodeca_unrotated, paraboloid);
    // auto& our_moments = volume_and_surface.getMoments();
    // auto& surface = volume_and_surface.getSurface();
    const double length_scale = 0.0025;
    TriangulatedSurfaceOutput triangulated_surface =
        surface.triangulate(length_scale);
    triangulated_surface.write(surf_filename);

    std::cout << seg_half_edge;
    VTKOutput vtk_io("dodeca_out", "viz", BasicMesh(1, 1, 1, 0));
    std::vector<ParametrizedSurfaceOutput> surfaces;
    surface.setLengthScale(length_scale);
    surfaces.push_back(surface);
    vtk_io.writeVTKInterface(0.0, surfaces, true);

    // auto our_moments = getVolumeMoments<VolumeMoments, HalfEdgeCutting>(
    //     dodeca_unrotated, paraboloid);

    std::cout << "-------------------------------------------------------------"
                 "---------------------------------------------------------"
              << std::endl;
    std::cout << "Test " << i + 1 << "/" << Ntests << std::endl;
    // error = fabs(our_moments - moments[0]);
    if (aligned_paraboloid.a() * aligned_paraboloid.b() > 0.0)
      std::cout << "ELLIPTIC" << std::endl;
    else if (aligned_paraboloid.a() * aligned_paraboloid.b() < 0.0)
      std::cout << "HYPERBOLIC" << std::endl;
    else
      std::cout << "PARABOLIC" << std::endl;
    // std::cout << std::setprecision(20) << "Volume polyhedron = " << poly_vol
    //           << std::endl;
    std::cout << std::setprecision(20)
              << "Vfrac unclipped IRL = " << our_moments.volume() / poly_vol
              << std::endl;
    std::cout << std::setprecision(20)
              << "Vfrac unclipped AMR = " << amr_moments.volume() / poly_vol
              << std::endl;
    std::cout << "Diff AMR/IRL = "
              << fabs(our_moments.volume() - amr_moments.volume()) / poly_vol
              << std::endl;
    std::cout << std::setprecision(20) << "Centroid unclipped AMR = "
              << amr_moments.centroid() / safelyEpsilon(amr_moments.volume())
              << std::endl;
    std::cout << std::setprecision(20) << "Centroid unclipped IRL = "
              << our_moments.centroid() / safelyEpsilon(our_moments.volume())
              << std::endl;
    std::cout << std::setprecision(20) << "Diff centroid AMR/IRL = "
              << Pt(fabs(our_moments.centroid()[0] - amr_moments.centroid()[0]),
                    fabs(our_moments.centroid()[1] - amr_moments.centroid()[1]),
                    fabs(our_moments.centroid()[2] - amr_moments.centroid()[2]))
              << std::endl;

    std::cout << "-------------------------------------------------------------"
                 "---------------------------------------------------------"
              << std::endl;

    max_error =
        max_error > fabs(our_moments.volume() - amr_moments.volume()) / poly_vol
            ? max_error
            : fabs(our_moments.volume() - amr_moments.volume()) / poly_vol;
    rms_error += fabs(our_moments.volume() - amr_moments.volume()) *
                 fabs(our_moments.volume() - amr_moments.volume()) / poly_vol /
                 poly_vol;

    if (fabs(our_moments.volume() - amr_moments.volume()) / poly_vol > 1.0e-10)
      exit(-1);
    if (magnitude(
            Pt(fabs(our_moments.centroid()[0] - amr_moments.centroid()[0]),
               fabs(our_moments.centroid()[1] - amr_moments.centroid()[1]),
               fabs(our_moments.centroid()[2] - amr_moments.centroid()[2]))) >
        1.0e-12)
      exit(-1);
  }
  rms_error = sqrt(rms_error / static_cast<double>(Ntests));

  std::cout << "Max error = " << max_error << std::endl;
  std::cout << "RMS error = " << rms_error << std::endl;
  std::cout << "-------------------------------------------------------------"
               "---------------------------------------------------------"
            << std::endl;

  EXPECT_NEAR(max_error, 0.0, 1.0e-12);
}

TEST(ParaboloidIntersection, getVolumeMomentsUse) {
  double tau = (std::sqrt(5.0) + 1.0) / 2.0;
  std::array<Pt, 12> M{
      {Pt(0, tau, 1), Pt(0.0, -tau, 1.0), Pt(0.0, tau, -1.0),
       Pt(0.0, -tau, -1.0), Pt(1.0, 0.0, tau), Pt(-1.0, 0.0, tau),
       Pt(1.0, 0.0, -tau), Pt(-1.0, 0.0, -tau), Pt(tau, 1.0, 0.0),
       Pt(-tau, 1.0, 0.0), Pt(tau, -1.0, 0.0), Pt(-tau, -1.0, 0.0)}};
  std::array<Pt, 20> vertex_list{{(1.0 / 3.0) * (M[0] + M[8] + M[2]),
                                  (1.0 / 3.0) * (M[0] + M[4] + M[8]),
                                  (1.0 / 3.0) * (M[0] + M[5] + M[4]),
                                  (1.0 / 3.0) * (M[0] + M[9] + M[5]),
                                  (1.0 / 3.0) * (M[0] + M[2] + M[9]),
                                  (1.0 / 3.0) * (M[2] + M[8] + M[6]),
                                  (1.0 / 3.0) * (M[8] + M[10] + M[6]),
                                  (1.0 / 3.0) * (M[8] + M[4] + M[10]),
                                  (1.0 / 3.0) * (M[4] + M[1] + M[10]),
                                  (1.0 / 3.0) * (M[4] + M[5] + M[1]),
                                  (1.0 / 3.0) * (M[5] + M[11] + M[1]),
                                  (1.0 / 3.0) * (M[5] + M[9] + M[11]),
                                  (1.0 / 3.0) * (M[9] + M[7] + M[11]),
                                  (1.0 / 3.0) * (M[9] + M[2] + M[7]),
                                  (1.0 / 3.0) * (M[2] + M[6] + M[7]),
                                  (1.0 / 3.0) * (M[3] + M[10] + M[1]),
                                  (1.0 / 3.0) * (M[3] + M[1] + M[11]),
                                  (1.0 / 3.0) * (M[3] + M[11] + M[7]),
                                  (1.0 / 3.0) * (M[3] + M[7] + M[6]),
                                  (1.0 / 3.0) * (M[3] + M[6] + M[10])}};

  std::array<std::array<UnsignedIndex_t, 5>, 12> face_mapping{
      {{5, 4, 3, 2, 1},
       {1, 2, 8, 7, 6},
       {2, 3, 10, 9, 8},
       {3, 4, 12, 11, 10},
       {4, 5, 14, 13, 12},
       {5, 1, 6, 15, 14},
       {16, 17, 18, 19, 20},
       {16, 20, 7, 8, 9},
       {9, 10, 11, 17, 16},
       {11, 12, 13, 18, 17},
       {6, 7, 20, 19, 15},
       {13, 14, 15, 19, 18}}};

  for (int i = 0; i < 12; i++) {
    for (int j = 0; j < 5; j++) {
      --face_mapping[i][j];
    }
  }

  double scale = 0.5;
  for (int i = 0; i < 20; i++) {
    vertex_list[i] *= scale;
  }

  int Ntests = 100;
  double max_error = 0.0, rms_error = 0.0;
  bool first_vertex_on_surface = false;
  HalfEdgePolyhedronParaboloid<Pt> half_edge;
  // Rotate cube
  std::random_device
      rd;  // Get a random seed from the OS entropy device, or whatever
  std::mt19937_64 eng(rd());  // Use the 64-bit Mersenne Twister 19937
                              // generator and seed it with entropy.
  static const int ncycles = 1;
  std::uniform_real_distribution<double> random_rotation(-0.5 * M_PI,
                                                         0.5 * M_PI);
  std::uniform_real_distribution<double> random_coeffs_a(-5.0, 5.0);
  std::uniform_real_distribution<double> random_coeffs_b(-5.0, 5.0);
  std::uniform_real_distribution<double> random_translation(-0.5, 0.5);

  PolyhedronConnectivity connectivity(face_mapping);
  for (int i = 0; i < Ntests; i++) {
    GeneralPolyhedron dodeca(vertex_list, &connectivity);
    GeneralPolyhedron dodeca_unrotated(vertex_list, &connectivity);
    AlignedParaboloid aligned_paraboloid;
    ReferenceFrame frame(Normal(1.0, 0.0, 0.0), Normal(0.0, 1.0, 0.0),
                         Normal(0.0, 0.0, 1.0));
    std::array<double, 3> angles{
        {random_rotation(eng), random_rotation(eng), 0.0}};
    Pt translations(random_translation(eng), random_translation(eng),
                    random_translation(eng));

    aligned_paraboloid.a() = random_coeffs_a(eng);
    aligned_paraboloid.b() = random_coeffs_b(eng);

    std::cout << "-------------------------------------------------------------"
                 "---------------------------------------------------------"
              << std::endl;
    std::cout << "Case setup." << std::endl;
    std::cout << "-------------------------------------------------------------"
                 "---------------------------------------------------------"
              << std::endl;

    std::cout << std::setprecision(20)
              << "aligned_paraboloid.a() = " << aligned_paraboloid.a() << ";"
              << std::endl;
    std::cout << std::setprecision(20)
              << "aligned_paraboloid.b() = " << aligned_paraboloid.b() << ";"
              << std::endl;
    std::cout << std::setprecision(20) << "angles[0] = " << angles[0] << ";"
              << std::endl;
    std::cout << std::setprecision(20) << "angles[1] = " << angles[1] << ";"
              << std::endl;
    std::cout << std::setprecision(20) << "angles[2] = " << angles[2] << ";"
              << std::endl;
    std::cout << std::setprecision(20)
              << "translations[0] = " << translations[0] << ";" << std::endl;
    std::cout << std::setprecision(20)
              << "translations[1] = " << translations[1] << ";" << std::endl;
    std::cout << std::setprecision(20)
              << "translations[2] = " << translations[2] << ";" << std::endl;

    if (first_vertex_on_surface) translations[2] = 0.0;

    UnitQuaternion x_rotation(angles[0], frame[0]);
    UnitQuaternion y_rotation(angles[1], frame[1]);
    UnitQuaternion z_rotation(angles[2], frame[2]);
    frame = x_rotation * y_rotation * z_rotation * frame;
    for (auto& vertex : dodeca) {
      Pt tmp_pt = vertex + translations;
      for (UnsignedIndex_t d = 0; d < 3; ++d) {
        vertex[d] = frame[d] * tmp_pt;
      }
    }

    double local_space_translation = 0.0;
    if (first_vertex_on_surface) {
      for (auto& vertex : dodeca) {
        Pt tmp_pt = vertex;
        local_space_translation =
            -aligned_paraboloid.a() * vertex[0] * vertex[0] -
            aligned_paraboloid.b() * vertex[1] * vertex[1] - vertex[2];
        break;
      }
      for (auto& vertex : dodeca) {
        vertex[2] += local_space_translation;
      }
    }
    translations += local_space_translation * frame[2];

    std::cout << "-------------------------------------------------------------"
                 "---------------------------------------------------------"
              << std::endl;
    std::cout << "IRL volume computation." << std::endl;
    std::cout << "-------------------------------------------------------------"
                 "---------------------------------------------------------"
              << std::endl;
    std::string poly_filename = "cell_" + std::to_string(i);
    std::string surf_filename = "surface_" + std::to_string(i);

    dodeca.setHalfEdgeVersion(&half_edge);
    auto seg_half_edge = half_edge.generateSegmentedPolyhedron();
    auto poly_vol = dodeca.calculateVolume();

    for (auto& face : seg_half_edge) {
      auto normal = Normal(0.0, 0.0, 0.0);
      const auto starting_half_edge = face->getStartingHalfEdge();
      auto current_half_edge = starting_half_edge;
      auto next_half_edge = starting_half_edge->getNextHalfEdge();
      const auto& start_location =
          starting_half_edge->getPreviousVertex()->getLocation();
      do {
        normal += crossProduct(
            current_half_edge->getVertex()->getLocation() - start_location,
            next_half_edge->getVertex()->getLocation() - start_location);
        current_half_edge = next_half_edge;
        next_half_edge = next_half_edge->getNextHalfEdge();
      } while (next_half_edge != starting_half_edge);
      normal.normalize();
      face->setPlane(Plane(normal, normal * start_location));
    }

    // auto amr_volume = intersectPolyhedronWithParaboloidAMR<Volume>(
    //     &seg_half_edge, &half_edge, aligned_paraboloid, 10,
    //     poly_filename);  // This prints the AMR triangles
    auto amr_volume = intersectPolyhedronWithParaboloidAMR<Volume>(
        &seg_half_edge, &half_edge, aligned_paraboloid, 17);

    auto datum = -translations;
    Paraboloid paraboloid(datum, frame, aligned_paraboloid.a(),
                          aligned_paraboloid.b());
    auto volume_and_surface =
        getVolumeMoments<AddSurfaceOutput<Volume, ParametrizedSurfaceOutput>,
                         HalfEdgeCutting>(dodeca_unrotated, paraboloid);

    const auto& our_volume = volume_and_surface.getMoments();
    const auto& surface = volume_and_surface.getSurface();

    const double length_scale = 0.0025;
    TriangulatedSurfaceOutput triangulated_surface =
        surface.triangulate(length_scale);
    triangulated_surface.write(surf_filename);

    std::cout << "-------------------------------------------------------------"
                 "---------------------------------------------------------"
              << std::endl;
    std::cout << "Test " << i + 1 << "/" << Ntests << std::endl;
    // error = fabs(our_volume - moments[0]);
    if (aligned_paraboloid.a() * aligned_paraboloid.b() > 0.0)
      std::cout << "ELLIPTIC" << std::endl;
    else if (aligned_paraboloid.a() * aligned_paraboloid.b() < 0.0)
      std::cout << "HYPERBOLIC" << std::endl;
    else
      std::cout << "PARABOLIC" << std::endl;
    // std::cout << std::setprecision(20) << "Volume polyhedron = " << poly_vol
    //           << std::endl;
    std::cout << std::setprecision(20)
              << "Vfrac unclipped IRL = " << our_volume / poly_vol << std::endl;
    std::cout << std::setprecision(20)
              << "Vfrac unclipped AMR = " << amr_volume / poly_vol << std::endl;
    std::cout << "Diff AMR/IRL = " << fabs(our_volume - amr_volume) / poly_vol
              << std::endl;
    std::cout << "-------------------------------------------------------------"
                 "---------------------------------------------------------"
              << std::endl;

    max_error = max_error > fabs(our_volume - amr_volume) / poly_vol
                    ? max_error
                    : fabs(our_volume - amr_volume) / poly_vol;
    rms_error += fabs(our_volume - amr_volume) * fabs(our_volume - amr_volume) /
                 poly_vol / poly_vol;

    if (fabs(our_volume - amr_volume) / poly_vol > 1.0e-10) exit(1);
  }
  rms_error = sqrt(rms_error / static_cast<double>(Ntests));

  std::cout << "Max error = " << max_error << std::endl;
  std::cout << "RMS error = " << rms_error << std::endl;
  std::cout << "-------------------------------------------------------------"
               "---------------------------------------------------------"
            << std::endl;

  EXPECT_NEAR(max_error, 0.0, 1.0e-13);
}

TEST(ParaboloidIntersection, TranslatingCube) {
  AlignedParaboloid aligned_paraboloid;
  aligned_paraboloid.a() = 1.0;  // DO NOT CHANGE
  aligned_paraboloid.b() = 1.0;  // DO NOT CHANGE
  std::array<double, 3> translations{{0.0, 0.0, 0.0}};
  ReferenceFrame frame(Normal(1.0, 0.0, 0.0), Normal(0.0, 1.0, 0.0),
                       Normal(0.0, 0.0, 1.0));
  auto datum = -Pt::fromArray(translations);
  Paraboloid paraboloid(datum, frame, aligned_paraboloid.a(),
                        aligned_paraboloid.b());

  //////////////////////////////// YOU CAN CHANGE THESE PARAMETERS
  int Ntests = 7;  // Number of tests
  double h = 1.0;  // Edge length of the cube
  ////////////////////////////////

  double max_volume_error = 0.0, rms_volume_error = 0.0;
  double max_surface_error = 0.0, rms_surface_error = 0.0;

  std::ofstream myfile;
  myfile.open("translating_cube.txt");
  myfile << "k m0 m0_ex m0_err m1x m1x_ex m1x_err m1z m1z_ex m1z_err m0s "
            "m0s_ex m0s_err\n";
  myfile.close();

  for (int i = 0; i < Ntests; i++) {
    double k = (2.0 * h * h + h) * static_cast<double>(i) /
               static_cast<double>(Ntests - 1);
    RectangularCuboid cube =
        RectangularCuboid::fromBoundingPts(Pt(0.0, 0.0, -k), Pt(h, h, h - k));
    HalfEdgePolyhedronParaboloid<Pt> half_edge;
    cube.setHalfEdgeVersion(&half_edge);
    auto seg_half_edge = half_edge.generateSegmentedPolyhedron();

    for (auto& face : seg_half_edge) {
      auto normal = Normal(0.0, 0.0, 0.0);
      const auto starting_half_edge = face->getStartingHalfEdge();
      auto current_half_edge = starting_half_edge;
      auto next_half_edge = starting_half_edge->getNextHalfEdge();
      const auto& start_location =
          starting_half_edge->getPreviousVertex()->getLocation();
      do {
        normal += crossProduct(
            current_half_edge->getVertex()->getLocation() - start_location,
            next_half_edge->getVertex()->getLocation() - start_location);
        current_half_edge = next_half_edge;
        next_half_edge = next_half_edge->getNextHalfEdge();
      } while (next_half_edge != starting_half_edge);
      normal.normalize();
      face->setPlane(Plane(normal, normal * start_location));
    }

    std::string poly_filename = "cell_" + std::to_string(i);
    std::string surf_filename = "surface_" + std::to_string(i);
    auto poly_vol = seg_half_edge.calculateVolume();
    // auto amr_volume_dummy = intersectPolyhedronWithParaboloidAMR<Volume>(
    //     &seg_half_edge, &half_edge, aligned_paraboloid, 10,
    //     poly_filename);  // This prints the AMR triangles
    // auto amr_moments = intersectPolyhedronWithParaboloidAMR<VolumeMoments>(
    //     &seg_half_edge, &half_edge, aligned_paraboloid, 17);
    auto amr_moments = VolumeMoments::fromScalarConstant(0.0);
    ParametrizedSurfaceOutput surface(paraboloid);
    auto our_moments = intersectPolyhedronWithParaboloid<VolumeMoments>(
        &seg_half_edge, &half_edge, aligned_paraboloid, &surface);
    auto our_surface_area = surface.getSurfaceArea();
    auto our_avg_normal = surface.getAverageNormal();
    auto our_avg_mean_curvature = surface.getAverageMeanCurvature();
    auto our_avg_gaussian_curvature = surface.getAverageGaussianCurvature();
    const double length_scale = pow(poly_vol, 1.0 / 3.0) * 0.01;
    TriangulatedSurfaceOutput triangulated_surface =
        surface.triangulate(length_scale);
    triangulated_surface.write(surf_filename);
    std::cout << "-------------------------------------------------------------"
                 "---------------------------------------------------------"
              << std::endl;
    std::cout << "Test " << i + 1 << "/" << Ntests << std::endl;

    double exact_volume = (std::pow(k, 2.) * M_PI) / 8.;
    double exact_m1x = (2. * std::pow(k, 2.5)) / 15.;
    double exact_m1z = -0.08333333333333333 * (std::pow(k, 3.) * M_PI);
    double exact_surface_area =
        ((-1. + std::sqrt(1. + 4. * k) + 4. * k * std::sqrt(1. + 4. * k)) *
         M_PI) /
        24.;
    if (k > h) {
      // std::cout << "Substract high quadrant" << std::endl;
      exact_volume -= (std::pow(h - k, 2.) * M_PI) / 8.;
      exact_surface_area -= ((-1. + std::sqrt(1. - 4. * h + 4. * k) -
                              4. * h * std::sqrt(1. - 4. * h + 4. * k) +
                              4. * k * std::sqrt(1. - 4. * h + 4. * k)) *
                             M_PI) /
                            24.;
      exact_m1x -= (2. * std::pow(-h + k, 2.5)) / 15.;
      exact_m1z -= (std::pow(h - k, 3.) * M_PI) / 12.;
    }
    if (k > h * h) {
      // std::cout << "Substract 2 low wedges" << std::endl;
      exact_volume -= (8. * std::pow(h, 3.) * std::sqrt(-std::pow(h, 2.) + k) -
                       20. * h * k * std::sqrt(-std::pow(h, 2.) + k) +
                       3. * std::pow(k, 2.) * M_PI -
                       6. * std::pow(k, 2.) *
                           std::atan(h / std::sqrt(-std::pow(h, 2.) + k)) +
                       6. * std::pow(k, 2.) *
                           std::atan(std::sqrt(-1. + k / std::pow(h, 2.)))) /
                      24.;
      exact_surface_area -=
          (-8. * h * std::sqrt(-((std::pow(h, 2.) - k) * (1. + 4. * k))) -
           M_PI + std::sqrt(1. + 4. * k) * M_PI +
           4. * k * std::sqrt(1. + 4. * k) * M_PI -
           2. * std::pow(1. + 4. * k, 1.5) *
               std::atan(h / std::sqrt(-std::pow(h, 2.) + k)) +
           2. * std::sqrt(1. + 4. * k) *
               std::atan(std::sqrt(-std::pow(h, 2.) + k) / h) +
           8. * k * std::sqrt(1. + 4. * k) *
               std::atan(std::sqrt(-std::pow(h, 2.) + k) / h) +
           2. * std::atan(4. * h *
                          std::sqrt((-std::pow(h, 2.) + k) / (1. + 4. * k))) +
           2. * std::atan((h * std::sqrt(1. + 4. * k)) /
                          std::sqrt(-std::pow(h, 2.) + k)) -
           2. * std::atan(std::sqrt((-std::pow(h, 2.) + k) * (1. + 4. * k)) /
                          h) -
           2. * h * (3. + 4. * std::pow(h, 2.)) *
               std::atanh(2. *
                          std::sqrt((-std::pow(h, 2.) + k) / (1. + 4. * k))) +
           3. * h * std::log(1. + 4. * std::pow(h, 2.)) +
           4. * std::pow(h, 3.) * std::log(1. + 4. * std::pow(h, 2.)) -
           6. * h *
               std::log(2. * std::sqrt(-std::pow(h, 2.) + k) +
                        std::sqrt(1. + 4. * k)) -
           8. * std::pow(h, 3.) *
               std::log(2. * std::sqrt(-std::pow(h, 2.) + k) +
                        std::sqrt(1. + 4. * k))) /
          24.;
      exact_m1x -= (-3. * std::pow(h, 5.) + 10. * std::pow(h, 3.) * k -
                    15. * h * std::pow(k, 2.) + 8. * std::pow(k, 2.5) +
                    8. * std::pow(-std::pow(h, 2.) + k, 2.5)) /
                   60.;
      exact_m1z -=
          (-16. * std::pow(h, 5.) * std::sqrt(-std::pow(h, 2.) + k) -
           8. * std::pow(h, 3.) * k * std::sqrt(-std::pow(h, 2.) + k) +
           84. * h * std::pow(k, 2.) * std::sqrt(-std::pow(h, 2.) + k) -
           15. * std::pow(k, 3.) * M_PI +
           30. * std::pow(k, 3.) *
               std::atan(h / std::sqrt(-std::pow(h, 2.) + k)) -
           30. * std::pow(k, 3.) *
               std::atan(std::sqrt(-1. + k / std::pow(h, 2.)))) /
          180.;
    }
    if (k > 2.0 * h * h) {
      // std::cout << "Adding 1 low triangle" << std::endl;
      exact_volume +=
          (2. * h *
               (-4. * std::pow(h, 3.) + 6. * h * k +
                2. * std::pow(h, 2.) * std::sqrt(-std::pow(h, 2.) + k) -
                5. * k * std::sqrt(-std::pow(h, 2.) + k)) -
           3. * std::pow(k, 2.) *
               std::atan(h / std::sqrt(-std::pow(h, 2.) + k)) +
           3. * std::pow(k, 2.) *
               std::atan(std::sqrt(-1. + k / std::pow(h, 2.)))) /
          12.;
      exact_surface_area +=
          (4. * std::pow(h, 2.) * std::sqrt(1. + 8. * std::pow(h, 2.)) -
           4. * h * std::sqrt(-((std::pow(h, 2.) - k) * (1. + 4. * k))) -
           std::atan((4. * std::pow(h, 2.)) /
                     std::sqrt(1. + 8. * std::pow(h, 2.))) -
           std::sqrt(1. + 4. * k) *
               std::atan(h / std::sqrt(-std::pow(h, 2.) + k)) -
           4. * k * std::sqrt(1. + 4. * k) *
               std::atan(h / std::sqrt(-std::pow(h, 2.) + k)) +
           std::sqrt(1. + 4. * k) *
               std::atan(std::sqrt(-std::pow(h, 2.) + k) / h) +
           4. * k * std::sqrt(1. + 4. * k) *
               std::atan(std::sqrt(-std::pow(h, 2.) + k) / h) +
           std::atan(4. * h *
                     std::sqrt((-std::pow(h, 2.) + k) / (1. + 4. * k))) +
           std::atan((h * std::sqrt(1. + 4. * k)) /
                     std::sqrt(-std::pow(h, 2.) + k)) -
           std::atan(std::sqrt((-std::pow(h, 2.) + k) * (1. + 4. * k)) / h) +
           h * (3. + 4. * std::pow(h, 2.)) *
               std::atanh((2. * h) / std::sqrt(1. + 8. * std::pow(h, 2.))) -
           h * (3. + 4. * std::pow(h, 2.)) *
               std::atanh(2. *
                          std::sqrt((-std::pow(h, 2.) + k) / (1. + 4. * k))) +
           3. * h * std::log(2. * h + std::sqrt(1. + 8. * std::pow(h, 2.))) +
           4. * std::pow(h, 3.) *
               std::log(2. * h + std::sqrt(1. + 8. * std::pow(h, 2.))) -
           3. * h *
               std::log(2. * std::sqrt(-std::pow(h, 2.) + k) +
                        std::sqrt(1. + 4. * k)) -
           4. * std::pow(h, 3.) *
               std::log(2. * std::sqrt(-std::pow(h, 2.) + k) +
                        std::sqrt(1. + 4. * k))) /
          12.;
      exact_m1x += (-28. * std::pow(h, 5.) + 40. * std::pow(h, 3.) * k -
                    15. * h * std::pow(k, 2.) +
                    8. * std::pow(-std::pow(h, 2.) + k, 2.5)) /
                   60.;
      exact_m1z +=
          (28. * std::pow(h, 6.) - 45. * std::pow(h, 2.) * std::pow(k, 2.) -
           8. * std::pow(h, 5.) * std::sqrt(-std::pow(h, 2.) + k) -
           4. * std::pow(h, 3.) * k * std::sqrt(-std::pow(h, 2.) + k) +
           42. * h * std::pow(k, 2.) * std::sqrt(-std::pow(h, 2.) + k) +
           15. * std::pow(k, 3.) *
               std::atan(h / std::sqrt(-std::pow(h, 2.) + k)) -
           15. * std::pow(k, 3.) *
               std::atan(std::sqrt(-std::pow(h, 2.) + k) / h)) /
          90.;
    }
    if ((k - h) > h * h) {
      // std::cout << "Adding 2 high wedges" << std::endl;
      exact_volume +=
          (20. * std::pow(h, 2.) * std::sqrt(-h - std::pow(h, 2.) + k) +
           8. * std::pow(h, 3.) * std::sqrt(-h - std::pow(h, 2.) + k) -
           20. * h * k * std::sqrt(-h - std::pow(h, 2.) + k) +
           3. * std::pow(h, 2.) * M_PI - 6. * h * k * M_PI +
           3. * std::pow(k, 2.) * M_PI +
           6. * std::pow(h - k, 2.) *
               std::atan(
                   std::sqrt(-((h + std::pow(h, 2.) - k) / std::pow(h, 2.)))) -
           6. * std::pow(h - k, 2.) *
               std::atan(h / std::sqrt(-h - std::pow(h, 2.) + k))) /
          24.;
      exact_surface_area +=
          (-8. * h *
               std::sqrt(4. * std::pow(h, 3.) +
                         std::pow(h, 2.) * (3. - 4. * k) + k * (1. + 4. * k) -
                         h * (1. + 8. * k)) -
           M_PI + std::sqrt(1. - 4. * h + 4. * k) * M_PI -
           4. * h * std::sqrt(1. - 4. * h + 4. * k) * M_PI +
           4. * k * std::sqrt(1. - 4. * h + 4. * k) * M_PI +
           2. * std::atan(h / std::sqrt((h + std::pow(h, 2.) - k) /
                                        (-1. + 4. * h - 4. * k))) +
           2. * std::atan(4. * h *
                          std::sqrt((h + std::pow(h, 2.) - k) /
                                    (-1. + 4. * h - 4. * k))) -
           2. * std::sqrt(1. - 4. * h + 4. * k) *
               std::atan(h / std::sqrt(-h - std::pow(h, 2.) + k)) +
           8. * h * std::sqrt(1. - 4. * h + 4. * k) *
               std::atan(h / std::sqrt(-h - std::pow(h, 2.) + k)) -
           8. * k * std::sqrt(1. - 4. * h + 4. * k) *
               std::atan(h / std::sqrt(-h - std::pow(h, 2.) + k)) +
           2. * std::sqrt(1. - 4. * h + 4. * k) *
               std::atan(std::sqrt(-h - std::pow(h, 2.) + k) / h) -
           8. * h * std::sqrt(1. - 4. * h + 4. * k) *
               std::atan(std::sqrt(-h - std::pow(h, 2.) + k) / h) +
           8. * k * std::sqrt(1. - 4. * h + 4. * k) *
               std::atan(std::sqrt(-h - std::pow(h, 2.) + k) / h) -
           2. * std::atan(std::sqrt(4. * std::pow(h, 3.) +
                                    std::pow(h, 2.) * (3. - 4. * k) +
                                    k * (1. + 4. * k) - h * (1. + 8. * k)) /
                          h) -
           2. * h * (3. + 4. * std::pow(h, 2.)) *
               std::atanh(2. * std::sqrt((h + std::pow(h, 2.) - k) /
                                         (-1. + 4. * h - 4. * k))) +
           3. * h * std::log(1. + 4. * std::pow(h, 2.)) +
           4. * std::pow(h, 3.) * std::log(1. + 4. * std::pow(h, 2.)) -
           6. * h *
               std::log(2. * std::sqrt(-h - std::pow(h, 2.) + k) +
                        std::sqrt(1. - 4. * h + 4. * k)) -
           8. * std::pow(h, 3.) *
               std::log(2. * std::sqrt(-h - std::pow(h, 2.) + k) +
                        std::sqrt(1. - 4. * h + 4. * k))) /
          24.;
      exact_m1x += (8. * std::pow(-h - std::pow(h, 2.) + k, 2.5) +
                    5. * h * (h + std::pow(h, 2.) - k) *
                        (-3. * h + std::pow(h, 2.) + 3. * k) +
                    8. * (-std::pow(h, 5.) + std::pow(-h + k, 2.5))) /
                   60.;
      exact_m1z +=
          (84. * std::pow(h, 3.) * std::sqrt(-h - std::pow(h, 2.) + k) +
           8. * std::pow(h, 4.) * std::sqrt(-h - std::pow(h, 2.) + k) -
           16. * std::pow(h, 5.) * std::sqrt(-h - std::pow(h, 2.) + k) -
           168. * std::pow(h, 2.) * k * std::sqrt(-h - std::pow(h, 2.) + k) -
           8. * std::pow(h, 3.) * k * std::sqrt(-h - std::pow(h, 2.) + k) +
           84. * h * std::pow(k, 2.) * std::sqrt(-h - std::pow(h, 2.) + k) +
           15. * std::pow(h, 3.) * M_PI - 45. * std::pow(h, 2.) * k * M_PI +
           45. * h * std::pow(k, 2.) * M_PI - 15. * std::pow(k, 3.) * M_PI -
           30. * std::pow(h - k, 3.) *
               std::atan(h / std::sqrt(-h - std::pow(h, 2.) + k)) +
           30. * std::pow(h - k, 3.) *
               std::atan(std::sqrt(-h - std::pow(h, 2.) + k) / h)) /
          180.;
    }
    auto exact_centroid =
        Pt(exact_m1x, exact_m1x, exact_m1z) / safelyEpsilon(exact_volume);
    auto amr_centroid =
        amr_moments.centroid() / safelyEpsilon(amr_moments.volume());
    auto our_centroid =
        our_moments.centroid() / safelyEpsilon(our_moments.volume());
    std::cout << std::setprecision(20)
              << "Surface EXACT  = " << exact_surface_area << std::endl;
    std::cout << std::setprecision(20)
              << "Surface IRL    = " << our_surface_area << std::endl;
    std::cout << std::setprecision(20) << "Normal IRL     = " << our_avg_normal
              << std::endl;
    std::cout << std::setprecision(20)
              << "Mean curv IRL     = " << our_avg_mean_curvature << std::endl;
    std::cout << std::setprecision(20)
              << "Gaussian curv IRL = " << our_avg_gaussian_curvature
              << std::endl;
    std::cout << std::setprecision(20)
              << "Vfrac unclipped EX  = " << exact_volume / poly_vol
              << std::endl;
    std::cout << std::setprecision(20)
              << "Vfrac unclipped IRL = " << our_moments.volume() / poly_vol
              << std::endl;
    std::cout << std::setprecision(20)
              << "Vfrac unclipped AMR = " << amr_moments.volume() / poly_vol
              << std::endl;
    std::cout << std::setprecision(20)
              << "Centroid unclipped EX  = " << exact_centroid << std::endl;
    std::cout << std::setprecision(20)
              << "Centroid unclipped IRL = " << our_centroid << std::endl;
    std::cout << std::setprecision(20)
              << "Centroid unclipped AMR = " << amr_centroid << std::endl;
    std::cout << "Diff Surface EX/IRL = "
              << fabs(our_surface_area - exact_surface_area) /
                     std::pow(poly_vol, 2.0 / 3.0)
              << std::endl;
    std::cout << "Diff Vfrac EX/IRL   = "
              << fabs(our_moments.volume() - exact_volume) / poly_vol
              << std::endl;
    std::cout << "Diff Vfrac AMR/IRL   = "
              << fabs(our_moments.volume() - amr_moments.volume()) / poly_vol
              << std::endl;
    std::cout << "Diff centroid EX/AMR   = "
              << Pt(exact_centroid - amr_centroid) /
                     std::pow(poly_vol, 1.0 / 3.0)
              << std::endl;
    std::cout << "Diff centroid EX/IRL   = "
              << Pt(exact_centroid - our_centroid) /
                     std::pow(poly_vol, 1.0 / 3.0)
              << std::endl;

    std::cout << "-------------------------------------------------------------"
                 "---------------------------------------------------------"
              << std::endl;

    myfile.open("translating_cube.txt", std::ios::app);
    // myfile << "k m0_err m1x_err m1z_err m0s_err\n";
    myfile << std::scientific << std::setprecision(20) << k << " "
           << our_moments.volume() << " " << exact_volume << " "
           << fabs(our_moments.volume() - exact_volume) << " "
           << our_moments.centroid()[0] << " " << exact_m1x << " "
           << fabs(our_moments.centroid()[0] - exact_m1x) << " "
           << our_moments.centroid()[2] << " " << exact_m1z << " "
           << fabs(our_moments.centroid()[2] - exact_m1z) << " "
           << our_surface_area << " " << exact_surface_area << " "
           << fabs(our_surface_area - exact_surface_area) << "\n";
    myfile.close();

    max_volume_error =
        max_volume_error > fabs(our_moments.volume() - exact_volume) / poly_vol
            ? max_volume_error
            : fabs(our_moments.volume() - exact_volume) / poly_vol;
    max_surface_error =
        max_surface_error > fabs(our_surface_area - exact_surface_area) /
                                std::pow(poly_vol, 2.0 / 3.0)
            ? max_surface_error
            : fabs(our_surface_area - exact_surface_area) /
                  std::pow(poly_vol, 2.0 / 3.0);
    rms_volume_error += fabs(our_moments.volume() - exact_volume) *
                        fabs(our_moments.volume() - exact_volume) / poly_vol /
                        poly_vol;
    rms_surface_error += fabs(our_surface_area - exact_surface_area) *
                         fabs(our_surface_area - exact_surface_area) /
                         std::pow(poly_vol, 4.0 / 3.0);

    if (fabs(our_moments.volume() - exact_volume) / poly_vol > 1.0e-10) exit(1);
  }
  rms_volume_error = sqrt(rms_volume_error / static_cast<double>(Ntests));
  rms_surface_error = sqrt(rms_surface_error / static_cast<double>(Ntests));

  std::cout << "Max surface error = " << max_surface_error << std::endl;
  std::cout << "RMS surface error = " << rms_surface_error << std::endl;
  std::cout << "Max volume error  = " << max_volume_error << std::endl;
  std::cout << "RMS volume error  = " << rms_volume_error << std::endl;
  std::cout << "-------------------------------------------------------------"
               "---------------------------------------------------------"
            << std::endl;

  EXPECT_NEAR(max_volume_error, 0.0, 1.0e-13);
}

TEST(ParaboloidIntersection, LocalizedParaboloid) {
  RectangularCuboid uc = unit_cell;
  PlanarLocalizer localizer = uc.getLocalizer();

  RectangularCuboid bigger_cube = RectangularCuboid::fromBoundingPts(
      Pt(-1.0, -1.0, -1.0), Pt(1.0, 1.0, 1.0));

  int Ntests = 2000;
  double max_error = 0.0, rms_error = 0.0;
  HalfEdgePolyhedronParaboloid<Pt> half_edge;
  // Rotate cube
  std::random_device
      rd;  // Get a random seed from the OS entropy device, or whatever
  std::mt19937_64 eng(rd());  // Use the 64-bit Mersenne Twister 19937
                              // generator and seed it with entropy.
  static const int ncycles = 1;
  std::uniform_real_distribution<double> random_rotation(-0.5 * M_PI,
                                                         0.5 * M_PI);
  std::uniform_real_distribution<double> random_coeffs_a(-5.0, 5.0);
  std::uniform_real_distribution<double> random_coeffs_b(-5.0, 5.0);
  std::uniform_real_distribution<double> random_translation(-0.5, 0.5);

  for (int i = 0; i < Ntests; i++) {
    AlignedParaboloid aligned_paraboloid;
    ReferenceFrame frame(Normal(1.0, 0.0, 0.0), Normal(0.0, 1.0, 0.0),
                         Normal(0.0, 0.0, 1.0));
    std::array<double, 3> angles{
        {random_rotation(eng), random_rotation(eng), 0.0}};
    Pt translations(random_translation(eng), random_translation(eng),
                    random_translation(eng));

    aligned_paraboloid.a() = random_coeffs_a(eng);
    aligned_paraboloid.b() = random_coeffs_b(eng);

    std::cout << "-------------------------------------------------------------"
                 "---------------------------------------------------------"
              << std::endl;
    std::cout << "Case setup." << std::endl;
    std::cout << "-------------------------------------------------------------"
                 "---------------------------------------------------------"
              << std::endl;

    std::cout << std::setprecision(20)
              << "aligned_paraboloid.a() = " << aligned_paraboloid.a() << ";"
              << std::endl;
    std::cout << std::setprecision(20)
              << "aligned_paraboloid.b() = " << aligned_paraboloid.b() << ";"
              << std::endl;
    std::cout << std::setprecision(20) << "angles[0] = " << angles[0] << ";"
              << std::endl;
    std::cout << std::setprecision(20) << "angles[1] = " << angles[1] << ";"
              << std::endl;
    std::cout << std::setprecision(20) << "angles[2] = " << angles[2] << ";"
              << std::endl;
    std::cout << std::setprecision(20)
              << "translations[0] = " << translations[0] << ";" << std::endl;
    std::cout << std::setprecision(20)
              << "translations[1] = " << translations[1] << ";" << std::endl;
    std::cout << std::setprecision(20)
              << "translations[2] = " << translations[2] << ";" << std::endl;

    std::cout << "-------------------------------------------------------------"
                 "---------------------------------------------------------"
              << std::endl;
    std::cout << "IRL volume computation." << std::endl;
    std::cout << "-------------------------------------------------------------"
                 "---------------------------------------------------------"
              << std::endl;
    std::string poly_filename = "cell_" + std::to_string(i);
    std::string surf_filename = "surface_" + std::to_string(i);

    bigger_cube.setHalfEdgeVersion(&half_edge);
    auto seg_half_edge = half_edge.generateSegmentedPolyhedron();
    localizeInternalToReconstruction(&seg_half_edge, &half_edge, localizer);

    UnitQuaternion x_rotation(angles[0], frame[0]);
    UnitQuaternion y_rotation(angles[1], frame[1]);
    UnitQuaternion z_rotation(angles[2], frame[2]);
    auto total_rotation = x_rotation * y_rotation * z_rotation;
    total_rotation.normalize();
    frame = total_rotation * frame;

    for (UnsignedIndex_t v = 0; v < seg_half_edge.getNumberOfVertices(); ++v) {
      const Pt tmp_pt =
          seg_half_edge.getVertex(v)->getLocation().getPt() + translations;
      auto new_pt = tmp_pt;
      for (UnsignedIndex_t d = 0; d < 3; ++d) {
        new_pt[d] = frame[d] * tmp_pt;
      }
      seg_half_edge.getVertex(v)->setLocation(new_pt);
    }

    auto poly_vol = seg_half_edge.calculateVolume();

    for (auto& face : seg_half_edge) {
      auto normal = Normal(0.0, 0.0, 0.0);
      const auto starting_half_edge = face->getStartingHalfEdge();
      auto current_half_edge = starting_half_edge;
      auto next_half_edge = starting_half_edge->getNextHalfEdge();
      const auto& start_location =
          starting_half_edge->getPreviousVertex()->getLocation();
      do {
        normal += crossProduct(
            current_half_edge->getVertex()->getLocation() - start_location,
            next_half_edge->getVertex()->getLocation() - start_location);
        current_half_edge = next_half_edge;
        next_half_edge = next_half_edge->getNextHalfEdge();
      } while (next_half_edge != starting_half_edge);
      normal.normalize();
      face->setPlane(Plane(normal, normal * start_location));
    }

    // auto amr_volume = intersectPolyhedronWithParaboloidAMR<Volume>(
    //     &seg_half_edge, &half_edge, aligned_paraboloid, 10,
    //     poly_filename);  // This prints the AMR triangles
    auto amr_volume = intersectPolyhedronWithParaboloidAMR<Volume>(
        &seg_half_edge, &half_edge, aligned_paraboloid, 17);

    auto datum = -translations;
    Paraboloid paraboloid(datum, frame, aligned_paraboloid.a(),
                          aligned_paraboloid.b());

    LocalizedParaboloid localized_paraboloid(&localizer, &paraboloid);
    // auto volume_and_surface =
    //     getVolumeMoments<AddSurfaceOutput<Volume, ParametrizedSurfaceOutput>,
    //                      HalfEdgeCutting>(bigger_cube, localized_paraboloid);

    // const auto& our_volume = volume_and_surface.getMoments();
    // const auto& surface = volume_and_surface.getSurface();

    // const double length_scale = 0.0025;
    // TriangulatedSurfaceOutput triangulated_surface =
    //     surface.triangulate(length_scale);
    // triangulated_surface.write(surf_filename);

    auto our_volume = getVolumeMoments<Volume, HalfEdgeCutting>(
        bigger_cube, localized_paraboloid);

    std::cout << "-------------------------------------------------------------"
                 "---------------------------------------------------------"
              << std::endl;
    std::cout << "Test " << i + 1 << "/" << Ntests << std::endl;
    // error = fabs(our_volume - moments[0]);
    if (aligned_paraboloid.a() * aligned_paraboloid.b() > 0.0)
      std::cout << "ELLIPTIC" << std::endl;
    else if (aligned_paraboloid.a() * aligned_paraboloid.b() < 0.0)
      std::cout << "HYPERBOLIC" << std::endl;
    else
      std::cout << "PARABOLIC" << std::endl;
    std::cout << std::setprecision(20) << "Volume polyhedron = " << poly_vol
              << std::endl;
    std::cout << std::setprecision(20)
              << "Vfrac unclipped IRL = " << our_volume / poly_vol << std::endl;
    std::cout << std::setprecision(20)
              << "Vfrac unclipped AMR = " << amr_volume / poly_vol << std::endl;
    std::cout << "Diff AMR/IRL = " << fabs(our_volume - amr_volume) / poly_vol
              << std::endl;
    std::cout << "-------------------------------------------------------------"
                 "---------------------------------------------------------"
              << std::endl;

    max_error = max_error > fabs(our_volume - amr_volume) / poly_vol
                    ? max_error
                    : fabs(our_volume - amr_volume) / poly_vol;
    rms_error += fabs(our_volume - amr_volume) * fabs(our_volume - amr_volume) /
                 poly_vol / poly_vol;

    if (fabs(our_volume - amr_volume) / poly_vol > 1.0e-10) exit(1);
  }
  rms_error = sqrt(rms_error / static_cast<double>(Ntests));

  std::cout << "Max error = " << max_error << std::endl;
  std::cout << "RMS error = " << rms_error << std::endl;
  std::cout << "-------------------------------------------------------------"
               "---------------------------------------------------------"
            << std::endl;

  EXPECT_NEAR(max_error, 0.0, 1.0e-13);
}

TEST(ParaboloidIntersection, LocalizedParaboloidLink) {
  RectangularCuboid uc = unit_cell;
  auto localizer = uc.getLocalizer();

  Paraboloid paraboloid;
  std::array<std::array<std::array<RectangularCuboid, 3>, 3>, 3> grid;
  std::array<std::array<std::array<PlanarLocalizer, 3>, 3>, 3> localizers;
  std::array<std::array<std::array<LocalizedParaboloidLink, 3>, 3>, 3>
      locpar_link;
  const double dx = 1.0 / 3.0;
  for (UnsignedIndex_t i = 0; i < 3; ++i) {
    for (UnsignedIndex_t j = 0; j < 3; ++j) {
      for (UnsignedIndex_t k = 0; k < 3; ++k) {
        Pt lower(-0.5 + static_cast<double>(i) * dx,
                 -0.5 + static_cast<double>(j) * dx,
                 -0.5 + static_cast<double>(k) * dx);
        Pt upper = lower + Pt(dx, dx, dx);
        grid[i][j][k] = RectangularCuboid::fromBoundingPts(lower, upper);
        localizers[i][j][k] = grid[i][j][k].getLocalizer();
        locpar_link[i][j][k] =
            LocalizedParaboloidLink(&(localizers[i][j][k]), &paraboloid);

        locpar_link[i][j][k].setId(k + j * 3 + i * 9);
        locpar_link[i][j][k].setEdgeConnectivity(
            0, i == 0 ? nullptr : &(locpar_link[i - 1][j][k]));
        locpar_link[i][j][k].setEdgeConnectivity(
            1, i == 2 ? nullptr : &(locpar_link[i + 1][j][k]));
        locpar_link[i][j][k].setEdgeConnectivity(
            2, j == 0 ? nullptr : &(locpar_link[i][j - 1][k]));
        locpar_link[i][j][k].setEdgeConnectivity(
            3, j == 2 ? nullptr : &(locpar_link[i][j + 1][k]));
        locpar_link[i][j][k].setEdgeConnectivity(
            4, k == 0 ? nullptr : &(locpar_link[i][j][k - 1]));
        locpar_link[i][j][k].setEdgeConnectivity(
            5, k == 2 ? nullptr : &(locpar_link[i][j][k + 1]));
      }
    }
  }

  RectangularCuboid bigger_cube = RectangularCuboid::fromBoundingPts(
      Pt(-1.0, -1.0, -1.0), Pt(1.0, 1.0, 1.0));

  int Ntests = 500;
  double max_error = 0.0, rms_error = 0.0;
  HalfEdgePolyhedronParaboloid<Pt> half_edge;
  // Rotate cube
  std::random_device
      rd;  // Get a random seed from the OS entropy device, or whatever
  std::mt19937_64 eng(rd());  // Use the 64-bit Mersenne Twister 19937
                              // generator and seed it with entropy.
  static const int ncycles = 1;
  std::uniform_real_distribution<double> random_rotation(-0.5 * M_PI,
                                                         0.5 * M_PI);
  std::uniform_real_distribution<double> random_coeffs_a(-5.0, 5.0);
  std::uniform_real_distribution<double> random_coeffs_b(-5.0, 5.0);
  std::uniform_real_distribution<double> random_translation(-0.5, 0.5);

  for (int i = 0; i < Ntests; i++) {
    AlignedParaboloid aligned_paraboloid;
    ReferenceFrame orig_frame(Normal(1.0, 0.0, 0.0), Normal(0.0, 1.0, 0.0),
                              Normal(0.0, 0.0, 1.0));
    std::array<double, 3> angles{
        {random_rotation(eng), random_rotation(eng), 0.0}};
    Pt translations(random_translation(eng), random_translation(eng),
                    random_translation(eng));

    aligned_paraboloid.a() = random_coeffs_a(eng);
    aligned_paraboloid.b() = random_coeffs_b(eng);

    // aligned_paraboloid.a() = 3.7232624152992084277;
    // aligned_paraboloid.b() = 1.8950188549060298371;
    // angles[0] = -1.3487640961867572997;
    // angles[1] = -0.69355356026013836868;
    // angles[2] = 0;
    // translations[0] = -0.2621252177522989113;
    // translations[1] = 0.29240199304985992068;
    // translations[2] = -0.45452163691874047924;

    std::cout << "-------------------------------------------------------------"
                 "---------------------------------------------------------"
              << std::endl;
    std::cout << "Case setup." << std::endl;
    std::cout << "-------------------------------------------------------------"
                 "---------------------------------------------------------"
              << std::endl;

    std::cout << std::setprecision(20)
              << "aligned_paraboloid.a() = " << aligned_paraboloid.a() << ";"
              << std::endl;
    std::cout << std::setprecision(20)
              << "aligned_paraboloid.b() = " << aligned_paraboloid.b() << ";"
              << std::endl;
    std::cout << std::setprecision(20) << "angles[0] = " << angles[0] << ";"
              << std::endl;
    std::cout << std::setprecision(20) << "angles[1] = " << angles[1] << ";"
              << std::endl;
    std::cout << std::setprecision(20) << "angles[2] = " << angles[2] << ";"
              << std::endl;
    std::cout << std::setprecision(20)
              << "translations[0] = " << translations[0] << ";" << std::endl;
    std::cout << std::setprecision(20)
              << "translations[1] = " << translations[1] << ";" << std::endl;
    std::cout << std::setprecision(20)
              << "translations[2] = " << translations[2] << ";" << std::endl;

    std::cout << "-------------------------------------------------------------"
                 "---------------------------------------------------------"
              << std::endl;
    std::cout << "IRL volume computation." << std::endl;
    std::cout << "-------------------------------------------------------------"
                 "---------------------------------------------------------"
              << std::endl;
    std::string poly_filename = "cell_" + std::to_string(i);
    std::string surf_filename = "surface_" + std::to_string(i);

    UnitQuaternion x_rotation(angles[0], orig_frame[0]);
    UnitQuaternion y_rotation(angles[1], orig_frame[1]);
    UnitQuaternion z_rotation(angles[2], orig_frame[2]);
    auto total_rotation = x_rotation * y_rotation * z_rotation;
    total_rotation.normalize();
    ReferenceFrame frame = total_rotation * orig_frame;

    std::array<std::array<std::array<double, 3>, 3>, 3> amr_volumes;
    double total_amr_volume = 0.0;
    for (UnsignedIndex_t i = 0; i < 3; ++i) {
      for (UnsignedIndex_t j = 0; j < 3; ++j) {
        for (UnsignedIndex_t k = 0; k < 3; ++k) {
          grid[i][j][k].setHalfEdgeVersion(&half_edge);
          auto seg_half_edge = half_edge.generateSegmentedPolyhedron();
          localizeInternalToReconstruction(&seg_half_edge, &half_edge,
                                           localizer);

          for (UnsignedIndex_t v = 0; v < seg_half_edge.getNumberOfVertices();
               ++v) {
            const Pt tmp_pt =
                seg_half_edge.getVertex(v)->getLocation().getPt() +
                translations;
            auto new_pt = tmp_pt;
            for (UnsignedIndex_t d = 0; d < 3; ++d) {
              new_pt[d] = frame[d] * tmp_pt;
            }
            seg_half_edge.getVertex(v)->setLocation(new_pt);
          }

          for (auto& face : seg_half_edge) {
            auto normal = Normal(0.0, 0.0, 0.0);
            const auto starting_half_edge = face->getStartingHalfEdge();
            auto current_half_edge = starting_half_edge;
            auto next_half_edge = starting_half_edge->getNextHalfEdge();
            const auto& start_location =
                starting_half_edge->getPreviousVertex()->getLocation();
            do {
              normal += crossProduct(
                  current_half_edge->getVertex()->getLocation() -
                      start_location,
                  next_half_edge->getVertex()->getLocation() - start_location);
              current_half_edge = next_half_edge;
              next_half_edge = next_half_edge->getNextHalfEdge();
            } while (next_half_edge != starting_half_edge);
            normal.normalize();
            face->setPlane(Plane(normal, normal * start_location));
          }

          // auto amr_volume = intersectPolyhedronWithParaboloidAMR<Volume>(
          //     &seg_half_edge, &half_edge, aligned_paraboloid, 10,
          //     poly_filename);  // This prints the AMR triangles

          amr_volumes[i][j][k] = intersectPolyhedronWithParaboloidAMR<Volume>(
              &seg_half_edge, &half_edge, aligned_paraboloid, 17);
          total_amr_volume += amr_volumes[i][j][k];
        }
      }
    }

    auto datum = -translations;
    paraboloid = Paraboloid(datum, frame, aligned_paraboloid.a(),
                            aligned_paraboloid.b());

    // auto volume_and_surface =
    //     getVolumeMoments<AddSurfaceOutput<Volume,
    //     ParametrizedSurfaceOutput>,
    //                      HalfEdgeCutting>(bigger_cube,
    //                      localized_paraboloid);

    // const auto& our_volume = volume_and_surface.getMoments();
    // const auto& surface = volume_and_surface.getSurface();

    // const double length_scale = 0.0025;
    // TriangulatedSurfaceOutput triangulated_surface =
    //     surface.triangulate(length_scale);
    // triangulated_surface.write(surf_filename);

    auto our_volume =
        getVolumeMoments<TaggedAccumulatedVolumeMoments<Volume>,
                         HalfEdgeCutting>(bigger_cube, locpar_link[1][1][1]);

    double total_our_volume = 0.0;
    for (UnsignedIndex_t i = 0; i < 3; ++i) {
      for (UnsignedIndex_t j = 0; j < 3; ++j) {
        for (UnsignedIndex_t k = 0; k < 3; ++k) {
          const UnsignedIndex_t ind = k + j * 3 + i * 9;
          const double cell_volume = grid[i][j][k].calculateVolume();
          const double irl_vfrac = our_volume[ind] / cell_volume;
          const double amr_vfrac = amr_volumes[i][j][k] / cell_volume;

          total_our_volume += our_volume[ind];

          max_error = max_error > fabs(irl_vfrac - amr_vfrac)
                          ? max_error
                          : fabs(irl_vfrac - amr_vfrac);
          rms_error +=
              fabs(irl_vfrac - amr_vfrac) * fabs(irl_vfrac - amr_vfrac);

          if (std::fabs(irl_vfrac - amr_vfrac) > 1.0e-10) {
            std::cout << "CELL: " << ind << std::endl;
            std::cout << "IRL VFRAC " << irl_vfrac << std::endl;
            std::cout << "AMR VFRAC " << amr_vfrac << std::endl;
            exit(1);
          }
        }
      }
    }

    std::cout << "-------------------------------------------------------------"
                 "---------------------------------------------------------"
              << std::endl;
    std::cout << "Test " << i + 1 << "/" << Ntests << std::endl;
    // error = fabs(our_volume - moments[0]);
    if (aligned_paraboloid.a() * aligned_paraboloid.b() > 0.0)
      std::cout << "ELLIPTIC" << std::endl;
    else if (aligned_paraboloid.a() * aligned_paraboloid.b() < 0.0)
      std::cout << "HYPERBOLIC" << std::endl;
    else
      std::cout << "PARABOLIC" << std::endl;
    std::cout << std::setprecision(20)
              << "Vfrac unclipped IRL = " << total_our_volume << std::endl;
    std::cout << std::setprecision(20)
              << "Vfrac unclipped AMR = " << total_amr_volume << std::endl;
    std::cout << "Diff AMR/IRL = "
              << std::fabs(total_our_volume - total_amr_volume) << std::endl;
    std::cout << "-------------------------------------------------------------"
                 "---------------------------------------------------------"
              << std::endl;
  }
  rms_error = sqrt(rms_error / static_cast<double>(Ntests * 27));

  std::cout << "Max error = " << max_error << std::endl;
  std::cout << "RMS error = " << rms_error << std::endl;
  std::cout << "-------------------------------------------------------------"
               "---------------------------------------------------------"
            << std::endl;

  EXPECT_NEAR(max_error, 0.0, 1.0e-13);
}

TEST(ParaboloidIntersection, CentroidZ) {
  ReferenceFrame frame(Normal(1.0, 0.0, 0.0), Normal(0.0, 1.0, 0.0),
                       Normal(0.0, 0.0, 1.0));
  Paraboloid paraboloid_pos(Pt(0.0, 0.0, 0.0), frame, 1.0e-1, 1.0e-1);
  Paraboloid paraboloid_neg(Pt(0.0, 0.0, 0.0), frame, -1.0e-1, -1.0e-1);
  auto cell = RectangularCuboid::fromBoundingPts(Pt(-0.4, -0.4, -0.4),
                                                 Pt(0.6, 0.7, 0.8));
  HalfEdgePolyhedronParaboloid<Pt> half_edge;

  cell.setHalfEdgeVersion(&half_edge);
  auto seg_half_edge = half_edge.generateSegmentedPolyhedron();

  // for (UnsignedIndex_t v = 0; v < seg_half_edge.getNumberOfVertices(); ++v) {
  //   const Pt tmp_pt = seg_half_edge.getVertex(v)->getLocation().getPt() -
  //                     paraboloid_pos.getDatum();
  //   auto new_pt = tmp_pt;
  //   for (UnsignedIndex_t d = 0; d < 3; ++d) {
  //     new_pt[d] = frame[d] * tmp_pt;
  //   }
  //   seg_half_edge.getVertex(v)->setLocation(new_pt);
  // }

  for (auto& face : seg_half_edge) {
    auto normal = Normal(0.0, 0.0, 0.0);
    const auto starting_half_edge = face->getStartingHalfEdge();
    auto current_half_edge = starting_half_edge;
    auto next_half_edge = starting_half_edge->getNextHalfEdge();
    const auto& start_location =
        starting_half_edge->getPreviousVertex()->getLocation();
    do {
      normal += crossProduct(
          current_half_edge->getVertex()->getLocation() - start_location,
          next_half_edge->getVertex()->getLocation() - start_location);
      current_half_edge = next_half_edge;
      next_half_edge = next_half_edge->getNextHalfEdge();
    } while (next_half_edge != starting_half_edge);
    normal.normalize();
    face->setPlane(Plane(normal, normal * start_location));
  }

  auto amr_moments_pos = intersectPolyhedronWithParaboloidAMR<VolumeMoments>(
      &seg_half_edge, &half_edge, paraboloid_pos.getAlignedParaboloid(), 17);
  auto our_moments_pos =
      getVolumeMoments<VolumeMoments, HalfEdgeCutting>(cell, paraboloid_pos);
  auto amr_centroid_pos =
      amr_moments_pos.centroid() / safelyTiny(amr_moments_pos.volume());
  auto our_centroid_pos =
      our_moments_pos.centroid() / safelyTiny(our_moments_pos.volume());
  std::cout << "Volume POS" << amr_moments_pos.volume() << std::endl;
  std::cout << "Centoid POS" << amr_centroid_pos << std::endl;
  std::cout << "Centoid IRL POS" << our_centroid_pos << std::endl;
  auto amr_moments_neg = intersectPolyhedronWithParaboloidAMR<VolumeMoments>(
      &seg_half_edge, &half_edge, paraboloid_neg.getAlignedParaboloid(), 17);
  auto our_moments_neg =
      getVolumeMoments<VolumeMoments, HalfEdgeCutting>(cell, paraboloid_neg);
  auto amr_centroid_neg =
      amr_moments_neg.centroid() / safelyTiny(amr_moments_neg.volume());
  auto our_centroid_neg =
      our_moments_neg.centroid() / safelyTiny(our_moments_neg.volume());
  std::cout << "Volume NEG" << amr_moments_neg.volume() << std::endl;
  std::cout << "Centoid NEG" << amr_centroid_neg << std::endl;
  std::cout << "Centoid IRL NEG" << our_centroid_neg << std::endl;
}

TEST(ParaboloidIntersection, InfiniteSplit) {
  ReferenceFrame frame(Normal(0.0, -1.0, 0.0), Normal(0.0, 0.0, 1.0),
                       Normal(-1.0, 0.0, 0.0));
  Paraboloid paraboloid(Pt(-0.1, 0.25, 0.0), frame, 5.0, 0.0);
  auto cell = RectangularCuboid::fromBoundingPts(Pt(-0.1, 0.24, -0.01),
                                                 Pt(-0.08, 0.26, 0.01));
  HalfEdgePolyhedronParaboloid<Pt> half_edge;

  cell.setHalfEdgeVersion(&half_edge);
  auto seg_half_edge = half_edge.generateSegmentedPolyhedron();

  for (UnsignedIndex_t v = 0; v < seg_half_edge.getNumberOfVertices(); ++v) {
    const Pt tmp_pt = seg_half_edge.getVertex(v)->getLocation().getPt() -
                      paraboloid.getDatum();
    auto new_pt = tmp_pt;
    for (UnsignedIndex_t d = 0; d < 3; ++d) {
      new_pt[d] = frame[d] * tmp_pt;
    }
    seg_half_edge.getVertex(v)->setLocation(new_pt);
  }

  for (auto& face : seg_half_edge) {
    auto normal = Normal(0.0, 0.0, 0.0);
    const auto starting_half_edge = face->getStartingHalfEdge();
    auto current_half_edge = starting_half_edge;
    auto next_half_edge = starting_half_edge->getNextHalfEdge();
    const auto& start_location =
        starting_half_edge->getPreviousVertex()->getLocation();
    do {
      normal += crossProduct(
          current_half_edge->getVertex()->getLocation() - start_location,
          next_half_edge->getVertex()->getLocation() - start_location);
      current_half_edge = next_half_edge;
      next_half_edge = next_half_edge->getNextHalfEdge();
    } while (next_half_edge != starting_half_edge);
    normal.normalize();
    face->setPlane(Plane(normal, normal * start_location));
  }

  std::string poly_filename = "cell_" + std::to_string(0);
  auto amr_volume = intersectPolyhedronWithParaboloidAMR<Volume>(
      &seg_half_edge, &half_edge, paraboloid.getAlignedParaboloid(), 17,
      poly_filename);  // This prints the AMR triangles

  auto vol_frac = IRL::getVolumeFraction(cell, paraboloid);
}

TEST(ParaboloidIntersection, SortTimeComp) {
  double tau = (std::sqrt(5.0) + 1.0) / 2.0;
  std::array<Pt, 12> M{
      {Pt(0, tau, 1), Pt(0.0, -tau, 1.0), Pt(0.0, tau, -1.0),
       Pt(0.0, -tau, -1.0), Pt(1.0, 0.0, tau), Pt(-1.0, 0.0, tau),
       Pt(1.0, 0.0, -tau), Pt(-1.0, 0.0, -tau), Pt(tau, 1.0, 0.0),
       Pt(-tau, 1.0, 0.0), Pt(tau, -1.0, 0.0), Pt(-tau, -1.0, 0.0)}};
  std::array<Pt, 20> vertex_list{{(1.0 / 3.0) * (M[0] + M[8] + M[2]),
                                  (1.0 / 3.0) * (M[0] + M[4] + M[8]),
                                  (1.0 / 3.0) * (M[0] + M[5] + M[4]),
                                  (1.0 / 3.0) * (M[0] + M[9] + M[5]),
                                  (1.0 / 3.0) * (M[0] + M[2] + M[9]),
                                  (1.0 / 3.0) * (M[2] + M[8] + M[6]),
                                  (1.0 / 3.0) * (M[8] + M[10] + M[6]),
                                  (1.0 / 3.0) * (M[8] + M[4] + M[10]),
                                  (1.0 / 3.0) * (M[4] + M[1] + M[10]),
                                  (1.0 / 3.0) * (M[4] + M[5] + M[1]),
                                  (1.0 / 3.0) * (M[5] + M[11] + M[1]),
                                  (1.0 / 3.0) * (M[5] + M[9] + M[11]),
                                  (1.0 / 3.0) * (M[9] + M[7] + M[11]),
                                  (1.0 / 3.0) * (M[9] + M[2] + M[7]),
                                  (1.0 / 3.0) * (M[2] + M[6] + M[7]),
                                  (1.0 / 3.0) * (M[3] + M[10] + M[1]),
                                  (1.0 / 3.0) * (M[3] + M[1] + M[11]),
                                  (1.0 / 3.0) * (M[3] + M[11] + M[7]),
                                  (1.0 / 3.0) * (M[3] + M[7] + M[6]),
                                  (1.0 / 3.0) * (M[3] + M[6] + M[10])}};

  std::array<std::array<UnsignedIndex_t, 5>, 12> face_mapping{
      {{5, 4, 3, 2, 1},
       {1, 2, 8, 7, 6},
       {2, 3, 10, 9, 8},
       {3, 4, 12, 11, 10},
       {4, 5, 14, 13, 12},
       {5, 1, 6, 15, 14},
       {16, 17, 18, 19, 20},
       {16, 20, 7, 8, 9},
       {9, 10, 11, 17, 16},
       {11, 12, 13, 18, 17},
       {6, 7, 20, 19, 15},
       {13, 14, 15, 19, 18}}};

  for (int i = 0; i < 12; i++) {
    for (int j = 0; j < 5; j++) {
      --face_mapping[i][j];
    }
  }

  double scale = 0.5;
  for (int i = 0; i < 20; i++) {
    vertex_list[i] *= scale;
  }
  PolyhedronConnectivity connectivity(face_mapping);
  GeneralPolyhedron dodeca(vertex_list, &connectivity);

  int Ntests = 1e6;
  double max_error = 0.0, rms_error = 0.0;
  HalfEdgePolyhedronParaboloid<Pt> half_edge;
  // Rotate cube
  std::random_device
      rd;  // Get a random seed from the OS entropy device, or whatever
  std::mt19937_64 eng(rd());  // Use the 64-bit Mersenne Twister 19937
                              // generator and seed it with entropy.
  std::uniform_real_distribution<double> random_rotation(-0.5 * M_PI,
                                                         0.5 * M_PI);
  std::uniform_real_distribution<double> random_coeffs_a(-5.0, 5.0);
  std::uniform_real_distribution<double> random_coeffs_b(-5.0, 5.0);
  std::uniform_real_distribution<double> random_translation(-0.5, 0.5);

  std::vector<double> angles_vec(2 * Ntests);
  std::vector<double> translations_vec(3 * Ntests);
  std::vector<double> paraboloid_coefs_vec(2 * Ntests);

  for (int i = 0; i < Ntests; ++i) {
    angles_vec[2 * i] = random_rotation(eng);
    angles_vec[2 * i + 1] = random_rotation(eng);

    translations_vec[3 * i] = random_translation(eng);
    translations_vec[3 * i + 1] = random_translation(eng);
    translations_vec[3 * i + 2] = random_translation(eng);

    paraboloid_coefs_vec[2 * i] = random_coeffs_a(eng);
    paraboloid_coefs_vec[2 * i + 1] = random_coeffs_b(eng);
  }

  auto start = std::chrono::system_clock::now();
  double total_volume = 0.0;
  for (int i = 0; i < Ntests; i++) {
    ReferenceFrame frame(Normal(1.0, 0.0, 0.0), Normal(0.0, 1.0, 0.0),
                         Normal(0.0, 0.0, 1.0));
    std::array<double, 3> angles{{angles_vec[2 * i], angles_vec[2 * i + 1]}};
    Pt translations(translations_vec[3 * i], translations_vec[3 * i + 1],
                    translations_vec[3 * i + 2]);

    UnitQuaternion x_rotation(angles[0], frame[0]);
    UnitQuaternion y_rotation(angles[1], frame[1]);
    UnitQuaternion z_rotation(angles[2], frame[2]);
    auto total_rotation = x_rotation * y_rotation * z_rotation;
    total_rotation.normalize();
    frame = total_rotation * frame;

    Paraboloid paraboloid(-translations, frame, paraboloid_coefs_vec[2 * i],
                          paraboloid_coefs_vec[2 * i + 1]);

    auto volume = getVolumeMoments<Volume>(dodeca, paraboloid);
    total_volume += volume;
  }
  auto end = std::chrono::system_clock::now();
  std::chrono::duration<double> runtime = end - start;
  printf("Total UNSORTED run time: %20f \n\n", runtime.count());

  // start = std::chrono::system_clock::now();
  // for (int i = 0; i < Ntests; i++) {
  //   ReferenceFrame frame(Normal(1.0, 0.0, 0.0), Normal(0.0, 1.0, 0.0),
  //                        Normal(0.0, 0.0, 1.0));
  //   std::array<double, 3> angles{{angles_vec[2 * i], angles_vec[2 * i + 1]}};
  //   Pt translations(translations_vec[3 * i], translations_vec[3 * i + 1],
  //                   translations_vec[3 * i + 2]);

  //   UnitQuaternion x_rotation(angles[0], frame[0]);
  //   UnitQuaternion y_rotation(angles[1], frame[1]);
  //   UnitQuaternion z_rotation(angles[2], frame[2]);
  //   auto total_rotation = x_rotation * y_rotation * z_rotation;
  //   total_rotation.normalize();
  //   frame = total_rotation * frame;

  //   Paraboloid paraboloid(-translations, frame, paraboloid_coefs_vec[2 * i],
  //                         paraboloid_coefs_vec[2 * i + 1]);

  //   auto volume =
  //       getVolumeMoments<AddSurfaceOutput<Volume,
  //       ParametrizedSurfaceOutput>>(
  //           dodeca, paraboloid);
  // }
  // end = std::chrono::system_clock::now();
  // runtime = end - start;
  // printf("Total SORTED run time: %20f \n\n", runtime.count());
}

TEST(ParaboloidIntersection, Gradient) {
  using MyGradientType = ParaboloidGradientLocalZ;
  using MyPtType = PtWithGradient<MyGradientType>;
  auto data_unit_cell =
      StoredRectangularCuboid<MyPtType>::fromOtherPolytope(unit_cell);
  auto pt_unit_cell = StoredRectangularCuboid<Pt>::fromOtherPolytope(unit_cell);

  int Ntests = 1;
  double max_error = 0.0, rms_error = 0.0;
  // Rotate cube
  std::random_device
      rd;  // Get a random seed from the OS entropy device, or whatever
  std::mt19937_64 eng(rd());  // Use the 64-bit Mersenne Twister 19937
                              // generator and seed it with entropy.
  std::uniform_real_distribution<double> random_rotation(-0.5 * M_PI,
                                                         0.5 * M_PI);
  std::uniform_real_distribution<double> random_coeffs_a(-5.0, 5.0);
  std::uniform_real_distribution<double> random_coeffs_b(-5.0, 5.0);
  std::uniform_real_distribution<double> random_translation(-0.5, 0.5);

  std::vector<double> angles_vec(2 * Ntests);
  std::vector<double> translations_vec(3 * Ntests);
  std::vector<double> paraboloid_coefs_vec(2 * Ntests);

  for (int i = 0; i < Ntests; ++i) {
    angles_vec[2 * i] = random_rotation(eng);
    angles_vec[2 * i + 1] = random_rotation(eng);

    translations_vec[3 * i] = random_translation(eng);
    translations_vec[3 * i + 1] = random_translation(eng);
    translations_vec[3 * i + 2] = random_translation(eng);

    paraboloid_coefs_vec[2 * i] = random_coeffs_a(eng);
    paraboloid_coefs_vec[2 * i + 1] = random_coeffs_b(eng);
  }

  auto start = std::chrono::system_clock::now();
  double total_volume = 0.0;
  for (int i = 0; i < Ntests; i++) {
    ReferenceFrame frame(Normal(1.0, 0.0, 0.0), Normal(0.0, 1.0, 0.0),
                         Normal(0.0, 0.0, 1.0));
    std::array<double, 3> angles{{angles_vec[2 * i], angles_vec[2 * i + 1]}};
    Pt translations(translations_vec[3 * i], translations_vec[3 * i + 1],
                    translations_vec[3 * i + 2]);

    angles[0] = M_PI / 10.0;
    angles[1] = 0.0;
    translations[0] = 0.0;
    translations[1] = 0.0;
    translations[2] = 0.0;
    paraboloid_coefs_vec[2 * i] = 0.1;
    paraboloid_coefs_vec[2 * i + 1] = 0.1;

    UnitQuaternion x_rotation(angles[0], frame[0]);
    UnitQuaternion y_rotation(angles[1], frame[1]);
    UnitQuaternion z_rotation(angles[2], frame[2]);
    auto total_rotation = x_rotation * y_rotation * z_rotation;
    total_rotation.normalize();

    Paraboloid paraboloid(-translations, frame, paraboloid_coefs_vec[2 * i],
                          paraboloid_coefs_vec[2 * i + 1]);

    frame = total_rotation * frame;
    for (auto& vertex : data_unit_cell) {
      auto& pt = vertex.getPt();
      Pt tmp_pt = pt + translations;
      for (UnsignedIndex_t d = 0; d < 3; ++d) {
        pt[d] = frame[d] * tmp_pt;
      }
    }
    for (auto& vertex : pt_unit_cell) {
      Pt tmp_pt = vertex + translations;
      for (UnsignedIndex_t d = 0; d < 3; ++d) {
        vertex[d] = frame[d] * tmp_pt;
      }
    }

    HalfEdgePolyhedronParaboloid<MyPtType> half_edge;
    data_unit_cell.setHalfEdgeVersion(&half_edge);
    auto seg_half_edge = half_edge.generateSegmentedPolyhedron();
    for (auto& face : seg_half_edge) {
      auto normal = Normal(0.0, 0.0, 0.0);
      const auto starting_half_edge = face->getStartingHalfEdge();
      auto current_half_edge = starting_half_edge;
      auto next_half_edge = starting_half_edge->getNextHalfEdge();
      const auto& start_location =
          starting_half_edge->getPreviousVertex()->getLocation().getPt();
      do {
        normal +=
            crossProduct(current_half_edge->getVertex()->getLocation().getPt() -
                             start_location,
                         next_half_edge->getVertex()->getLocation().getPt() -
                             start_location);
        current_half_edge = next_half_edge;
        next_half_edge = next_half_edge->getNextHalfEdge();
      } while (next_half_edge != starting_half_edge);
      normal.normalize();
      face->setPlane(Plane(normal, normal * start_location));
    }

    auto volume_with_gradients =
        intersectPolyhedronWithParaboloid<VolumeWithGradient<MyGradientType>>(
            &seg_half_edge, &half_edge, paraboloid.getAlignedParaboloid());

    HalfEdgePolyhedronParaboloid<Pt> half_edge_pt;
    pt_unit_cell.setHalfEdgeVersion(&half_edge_pt);
    auto seg_half_edge_pt = half_edge.generateSegmentedPolyhedron();
    for (auto& face : seg_half_edge_pt) {
      auto normal = Normal(0.0, 0.0, 0.0);
      const auto starting_half_edge = face->getStartingHalfEdge();
      auto current_half_edge = starting_half_edge;
      auto next_half_edge = starting_half_edge->getNextHalfEdge();
      const auto& start_location =
          starting_half_edge->getPreviousVertex()->getLocation().getPt();
      do {
        normal +=
            crossProduct(current_half_edge->getVertex()->getLocation().getPt() -
                             start_location,
                         next_half_edge->getVertex()->getLocation().getPt() -
                             start_location);
        current_half_edge = next_half_edge;
        next_half_edge = next_half_edge->getNextHalfEdge();
      } while (next_half_edge != starting_half_edge);
      normal.normalize();
      face->setPlane(Plane(normal, normal * start_location));
    }

    auto amr_volume = intersectPolyhedronWithParaboloidAMR<Volume>(
        &seg_half_edge_pt, &half_edge_pt, paraboloid.getAlignedParaboloid(),
        17);

    double epsilon = std::sqrt(DBL_EPSILON);
    for (auto& vertex : pt_unit_cell) {
      vertex += Pt(0.0, 0.0, -epsilon);
    }
    auto volume_plus_epsilon =
        IRL::getVolumeMoments<Volume>(pt_unit_cell, paraboloid);
    for (auto& vertex : pt_unit_cell) {
      vertex += Pt(0.0, 0.0, +2.0 * epsilon);
    }
    auto volume_minus_epsilon =
        IRL::getVolumeMoments<Volume>(pt_unit_cell, paraboloid);

    std::cout << std::setprecision(20)
              << "Volume = " << volume_with_gradients.volume() << std::endl;
    std::cout << std::setprecision(20) << "Gradient = [" << std::endl;
    std::cout << std::setprecision(20) << "  A -> "
              << volume_with_gradients.volume_gradient().getGradA() << std::endl
              << std::setprecision(20) << "  B -> "
              << volume_with_gradients.volume_gradient().getGradB() << std::endl
              << std::setprecision(20) << " Tx -> "
              << volume_with_gradients.volume_gradient().getGradTx()
              << std::endl
              << std::setprecision(20) << " Ty -> "
              << volume_with_gradients.volume_gradient().getGradTy()
              << std::endl
              << std::setprecision(20) << " Tz -> "
              << volume_with_gradients.volume_gradient().getGradTz()
              << std::setprecision(20) << "      Finite differences -> "
              << (volume_plus_epsilon - volume_minus_epsilon) / (2.0 * epsilon)
              << std::setprecision(20) << "      Error -> "
              << std::fabs(volume_with_gradients.volume_gradient().getGradTz() -
                           (volume_plus_epsilon - volume_minus_epsilon) /
                               (2.0 * epsilon))
              << std::endl
              << std::setprecision(20) << " Rx -> "
              << volume_with_gradients.volume_gradient().getGradRx()
              << std::endl
              << std::setprecision(20) << " Ry -> "
              << volume_with_gradients.volume_gradient().getGradRy()
              << std::endl
              << std::setprecision(20) << " Rz -> "
              << volume_with_gradients.volume_gradient().getGradRz()
              << std::endl
              << "]" << std::endl;
    std::cout << std::setprecision(20) << "Volume difference = "
              << std::fabs(volume_with_gradients.volume() - amr_volume)
              << std::endl;
    total_volume += volume_with_gradients.volume();
  }
  auto end = std::chrono::system_clock::now();
  std::chrono::duration<double> runtime = end - start;
  printf("Total run time: %20f \n\n", runtime.count());
}

TEST(ParaboloidIntersection, TranslatingCubeGradientZ) {
  using MyGradientType = ParaboloidGradientLocal;
  using MyPtType = PtWithGradient<MyGradientType>;

  AlignedParaboloid aligned_paraboloid;
  aligned_paraboloid.a() = 1.0;  // DO NOT CHANGE
  aligned_paraboloid.b() = 1.0;  // DO NOT CHANGE
  std::array<double, 3> translations{{0.0, 0.0, 0.0}};
  ReferenceFrame frame(Normal(1.0, 0.0, 0.0), Normal(0.0, 1.0, 0.0),
                       Normal(0.0, 0.0, 1.0));
  auto datum = -Pt::fromArray(translations);
  Paraboloid paraboloid(datum, frame, aligned_paraboloid.a(),
                        aligned_paraboloid.b());

  //////////////////////////////// YOU CAN CHANGE THESE PARAMETERS
  int Ntests = 201;  // Number of tests
  double h = 0.75;   // Edge length of the cube
  ////////////////////////////////

  double max_volume_error = 0.0, rms_volume_error = 0.0;
  double max_surface_error = 0.0, rms_surface_error = 0.0;
  double max_gradient_error = 0.0, rms_gradient_error = 0.0;

  for (int i = 0; i < Ntests; i++) {
    double k = (2.0 * h * h + h) * static_cast<double>(i) /
               static_cast<double>(Ntests - 1);

    auto cube = StoredRectangularCuboid<MyPtType>::fromOtherPolytope(unit_cell);
    auto cube_pt = StoredRectangularCuboid<Pt>::fromOtherPolytope(unit_cell);
    for (auto& vertex : cube) {
      vertex = vertex * h;
      vertex += MyPtType(Pt(0.5 * h, 0.5 * h, 0.5 * h - k));
    }
    for (auto& vertex : cube_pt) {
      vertex = vertex * h;
      vertex += Pt(0.5 * h, 0.5 * h, 0.5 * h - k);
    }
    HalfEdgePolyhedronParaboloid<MyPtType> half_edge;
    cube.setHalfEdgeVersion(&half_edge);
    auto seg_half_edge = half_edge.generateSegmentedPolyhedron();

    for (auto& face : seg_half_edge) {
      auto normal = Normal(0.0, 0.0, 0.0);
      const auto starting_half_edge = face->getStartingHalfEdge();
      auto current_half_edge = starting_half_edge;
      auto next_half_edge = starting_half_edge->getNextHalfEdge();
      const auto& start_location =
          starting_half_edge->getPreviousVertex()->getLocation().getPt();
      do {
        normal +=
            crossProduct(current_half_edge->getVertex()->getLocation().getPt() -
                             start_location,
                         next_half_edge->getVertex()->getLocation().getPt() -
                             start_location);
        current_half_edge = next_half_edge;
        next_half_edge = next_half_edge->getNextHalfEdge();
      } while (next_half_edge != starting_half_edge);
      normal.normalize();
      face->setPlane(Plane(normal, normal * start_location));
    }

    std::string poly_filename = "cell_" + std::to_string(i);
    std::string surf_filename = "surface_" + std::to_string(i);
    auto poly_vol = seg_half_edge.calculateVolume();
    auto amr_volume_dummy = intersectPolyhedronWithParaboloidAMR<Volume>(
        &seg_half_edge, &half_edge, aligned_paraboloid, 10,
        poly_filename);  // This prints the AMR triangles
    ParametrizedSurfaceOutput surface(paraboloid);
    // auto our_moments_test = Volume::fromScalarConstant(0.0);
    // auto our_moments_test =
    //     VolumeWithGradient<MyGradientType>::fromScalarConstant(0.0);
    // auto start = std::chrono::system_clock::now();
    // for (int j = 0; j < 1.0e6; j++) {
    //   // our_moments_test += IRL::getVolumeMoments<Volume>(cube_pt,
    //   paraboloid); our_moments_test +=
    //       IRL::getVolumeMoments<VolumeWithGradient<MyGradientType>>(cube,
    //                                                                 paraboloid);
    // }
    // auto end = std::chrono::system_clock::now();
    // std::chrono::duration<double> runtime = end - start;
    // printf("Total run time: %20f \n\n", runtime.count());
    auto our_moments =
        intersectPolyhedronWithParaboloid<VolumeWithGradient<MyGradientType>>(
            &seg_half_edge, &half_edge, aligned_paraboloid, &surface);
    auto our_surface_area = surface.getSurfaceArea();
    auto our_avg_normal = surface.getAverageNormal();
    auto our_avg_mean_curvature = surface.getAverageMeanCurvature();
    auto our_avg_gaussian_curvature = surface.getAverageGaussianCurvature();
    const double length_scale = pow(poly_vol, 1.0 / 3.0) * 0.01;
    TriangulatedSurfaceOutput triangulated_surface =
        surface.triangulate(length_scale);
    triangulated_surface.write(surf_filename);
    std::cout << "-------------------------------------------------------------"
                 "---------------------------------------------------------"
              << std::endl;
    std::cout << "Test " << i + 1 << "/" << Ntests << std::endl;

    double epsilon = std::sqrt(DBL_EPSILON);
    for (auto& vertex : cube_pt) {
      vertex += Pt(0.0, 0.0, -epsilon);
    }
    auto volume_plus_epsilon =
        IRL::getVolumeMoments<Volume>(cube_pt, paraboloid);
    for (auto& vertex : cube_pt) {
      vertex += Pt(0.0, 0.0, +2.0 * epsilon);
    }
    auto volume_minus_epsilon =
        IRL::getVolumeMoments<Volume>(cube_pt, paraboloid);

    double gradZ_FD =
        (volume_plus_epsilon - volume_minus_epsilon) / (2.0 * epsilon);

    double exact_volume = (std::pow(k, 2.) * M_PI) / 8.;
    double exact_volume_gradk = (k * M_PI) / 4.;
    double exact_surface_area =
        ((-1. + std::sqrt(1. + 4. * k) + 4. * k * std::sqrt(1. + 4. * k)) *
         M_PI) /
        24.;
    if (k > h) {
      // std::cout << "Substract high quadrant" << std::endl;
      exact_volume -= (std::pow(h - k, 2.) * M_PI) / 8.;
      exact_volume_gradk -= -0.25 * ((h - k) * M_PI);
      exact_surface_area -= ((-1. + std::sqrt(1. - 4. * h + 4. * k) -
                              4. * h * std::sqrt(1. - 4. * h + 4. * k) +
                              4. * k * std::sqrt(1. - 4. * h + 4. * k)) *
                             M_PI) /
                            24.;
    }
    if (k > h * h) {
      // std::cout << "Substract 2 low wedges" << std::endl;
      exact_volume -= (8. * std::pow(h, 3.) * std::sqrt(-std::pow(h, 2.) + k) -
                       20. * h * k * std::sqrt(-std::pow(h, 2.) + k) +
                       3. * std::pow(k, 2.) * M_PI -
                       6. * std::pow(k, 2.) *
                           std::atan(h / std::sqrt(-std::pow(h, 2.) + k)) +
                       6. * std::pow(k, 2.) *
                           std::atan(std::sqrt(-1. + k / std::pow(h, 2.)))) /
                      24.;
      exact_volume_gradk -=
          ((4. * std::pow(h, 3.)) / std::sqrt(-std::pow(h, 2.) + k) -
           (10. * h * k) / std::sqrt(-std::pow(h, 2.) + k) -
           20. * h * std::sqrt(-std::pow(h, 2.) + k) +
           (3. * h * std::pow(k, 2.)) /
               (std::pow(-std::pow(h, 2.) + k, 1.5) *
                (1. + std::pow(h, 2.) / (-std::pow(h, 2.) + k))) +
           (3. * std::pow(k, 2.)) /
               (h * std::sqrt(-std::pow(h, 2.) + k) *
                (1. + (-std::pow(h, 2.) + k) / std::pow(h, 2.))) +
           6. * k * M_PI -
           12. * k * std::atan(h / std::sqrt(-std::pow(h, 2.) + k)) +
           12. * k * std::atan(std::sqrt(-std::pow(h, 2.) + k) / h)) /
          24.;
      exact_surface_area -=
          (-8. * h * std::sqrt(-((std::pow(h, 2.) - k) * (1. + 4. * k))) -
           M_PI + std::sqrt(1. + 4. * k) * M_PI +
           4. * k * std::sqrt(1. + 4. * k) * M_PI -
           2. * std::pow(1. + 4. * k, 1.5) *
               std::atan(h / std::sqrt(-std::pow(h, 2.) + k)) +
           2. * std::sqrt(1. + 4. * k) *
               std::atan(std::sqrt(-std::pow(h, 2.) + k) / h) +
           8. * k * std::sqrt(1. + 4. * k) *
               std::atan(std::sqrt(-std::pow(h, 2.) + k) / h) +
           2. * std::atan(4. * h *
                          std::sqrt((-std::pow(h, 2.) + k) / (1. + 4. * k))) +
           2. * std::atan((h * std::sqrt(1. + 4. * k)) /
                          std::sqrt(-std::pow(h, 2.) + k)) -
           2. * std::atan(std::sqrt((-std::pow(h, 2.) + k) * (1. + 4. * k)) /
                          h) -
           2. * h * (3. + 4. * std::pow(h, 2.)) *
               std::atanh(2. *
                          std::sqrt((-std::pow(h, 2.) + k) / (1. + 4. * k))) +
           3. * h * std::log(1. + 4. * std::pow(h, 2.)) +
           4. * std::pow(h, 3.) * std::log(1. + 4. * std::pow(h, 2.)) -
           6. * h *
               std::log(2. * std::sqrt(-std::pow(h, 2.) + k) +
                        std::sqrt(1. + 4. * k)) -
           8. * std::pow(h, 3.) *
               std::log(2. * std::sqrt(-std::pow(h, 2.) + k) +
                        std::sqrt(1. + 4. * k))) /
          24.;
    }
    if (k > 2.0 * h * h) {
      // std::cout << "Adding 1 low triangle" << std::endl;
      exact_volume +=
          (2. * h *
               (-4. * std::pow(h, 3.) + 6. * h * k +
                2. * std::pow(h, 2.) * std::sqrt(-std::pow(h, 2.) + k) -
                5. * k * std::sqrt(-std::pow(h, 2.) + k)) -
           3. * std::pow(k, 2.) *
               std::atan(h / std::sqrt(-std::pow(h, 2.) + k)) +
           3. * std::pow(k, 2.) *
               std::atan(std::sqrt(-1. + k / std::pow(h, 2.)))) /
          12.;
      exact_volume_gradk +=
          ((3. * h * std::pow(k, 2.)) /
               (2. * std::pow(-std::pow(h, 2.) + k, 1.5) *
                (1. + std::pow(h, 2.) / (-std::pow(h, 2.) + k))) +
           2. * h *
               (6. * h + std::pow(h, 2.) / std::sqrt(-std::pow(h, 2.) + k) -
                (5. * k) / (2. * std::sqrt(-std::pow(h, 2.) + k)) -
                5. * std::sqrt(-std::pow(h, 2.) + k)) +
           (3. * std::pow(k, 2.)) /
               (2. * h * std::sqrt(-std::pow(h, 2.) + k) *
                (1. + (-std::pow(h, 2.) + k) / std::pow(h, 2.))) -
           6. * k * std::atan(h / std::sqrt(-std::pow(h, 2.) + k)) +
           6. * k * std::atan(std::sqrt(-std::pow(h, 2.) + k) / h)) /
          12.;
      exact_surface_area +=
          (4. * std::pow(h, 2.) * std::sqrt(1. + 8. * std::pow(h, 2.)) -
           4. * h * std::sqrt(-((std::pow(h, 2.) - k) * (1. + 4. * k))) -
           std::atan((4. * std::pow(h, 2.)) /
                     std::sqrt(1. + 8. * std::pow(h, 2.))) -
           std::sqrt(1. + 4. * k) *
               std::atan(h / std::sqrt(-std::pow(h, 2.) + k)) -
           4. * k * std::sqrt(1. + 4. * k) *
               std::atan(h / std::sqrt(-std::pow(h, 2.) + k)) +
           std::sqrt(1. + 4. * k) *
               std::atan(std::sqrt(-std::pow(h, 2.) + k) / h) +
           4. * k * std::sqrt(1. + 4. * k) *
               std::atan(std::sqrt(-std::pow(h, 2.) + k) / h) +
           std::atan(4. * h *
                     std::sqrt((-std::pow(h, 2.) + k) / (1. + 4. * k))) +
           std::atan((h * std::sqrt(1. + 4. * k)) /
                     std::sqrt(-std::pow(h, 2.) + k)) -
           std::atan(std::sqrt((-std::pow(h, 2.) + k) * (1. + 4. * k)) / h) +
           h * (3. + 4. * std::pow(h, 2.)) *
               std::atanh((2. * h) / std::sqrt(1. + 8. * std::pow(h, 2.))) -
           h * (3. + 4. * std::pow(h, 2.)) *
               std::atanh(2. *
                          std::sqrt((-std::pow(h, 2.) + k) / (1. + 4. * k))) +
           3. * h * std::log(2. * h + std::sqrt(1. + 8. * std::pow(h, 2.))) +
           4. * std::pow(h, 3.) *
               std::log(2. * h + std::sqrt(1. + 8. * std::pow(h, 2.))) -
           3. * h *
               std::log(2. * std::sqrt(-std::pow(h, 2.) + k) +
                        std::sqrt(1. + 4. * k)) -
           4. * std::pow(h, 3.) *
               std::log(2. * std::sqrt(-std::pow(h, 2.) + k) +
                        std::sqrt(1. + 4. * k))) /
          12.;
    }
    if ((k - h) > h * h) {
      // std::cout << "Adding 2 high wedges" << std::endl;
      exact_volume +=
          (20. * std::pow(h, 2.) * std::sqrt(-h - std::pow(h, 2.) + k) +
           8. * std::pow(h, 3.) * std::sqrt(-h - std::pow(h, 2.) + k) -
           20. * h * k * std::sqrt(-h - std::pow(h, 2.) + k) +
           3. * std::pow(h, 2.) * M_PI - 6. * h * k * M_PI +
           3. * std::pow(k, 2.) * M_PI +
           6. * std::pow(h - k, 2.) *
               std::atan(
                   std::sqrt(-((h + std::pow(h, 2.) - k) / std::pow(h, 2.)))) -
           6. * std::pow(h - k, 2.) *
               std::atan(h / std::sqrt(-h - std::pow(h, 2.) + k))) /
          24.;
      exact_volume_gradk +=
          ((10. * std::pow(h, 2.)) / std::sqrt(-h - std::pow(h, 2.) + k) +
           (4. * std::pow(h, 3.)) / std::sqrt(-h - std::pow(h, 2.) + k) -
           (10. * h * k) / std::sqrt(-h - std::pow(h, 2.) + k) -
           20. * h * std::sqrt(-h - std::pow(h, 2.) + k) +
           (3. * h * std::pow(h - k, 2.)) /
               (std::pow(-h - std::pow(h, 2.) + k, 1.5) *
                (1. + std::pow(h, 2.) / (-h - std::pow(h, 2.) + k))) +
           (3. * std::pow(h - k, 2.)) /
               (h * std::sqrt(-h - std::pow(h, 2.) + k) *
                (1. + (-h - std::pow(h, 2.) + k) / std::pow(h, 2.))) -
           6. * h * M_PI + 6. * k * M_PI +
           12. * (h - k) * std::atan(h / std::sqrt(-h - std::pow(h, 2.) + k)) -
           12. * (h - k) * std::atan(std::sqrt(-h - std::pow(h, 2.) + k) / h)) /
          24.;
      exact_surface_area +=
          (-8. * h *
               std::sqrt(4. * std::pow(h, 3.) +
                         std::pow(h, 2.) * (3. - 4. * k) + k * (1. + 4. * k) -
                         h * (1. + 8. * k)) -
           M_PI + std::sqrt(1. - 4. * h + 4. * k) * M_PI -
           4. * h * std::sqrt(1. - 4. * h + 4. * k) * M_PI +
           4. * k * std::sqrt(1. - 4. * h + 4. * k) * M_PI +
           2. * std::atan(h / std::sqrt((h + std::pow(h, 2.) - k) /
                                        (-1. + 4. * h - 4. * k))) +
           2. * std::atan(4. * h *
                          std::sqrt((h + std::pow(h, 2.) - k) /
                                    (-1. + 4. * h - 4. * k))) -
           2. * std::sqrt(1. - 4. * h + 4. * k) *
               std::atan(h / std::sqrt(-h - std::pow(h, 2.) + k)) +
           8. * h * std::sqrt(1. - 4. * h + 4. * k) *
               std::atan(h / std::sqrt(-h - std::pow(h, 2.) + k)) -
           8. * k * std::sqrt(1. - 4. * h + 4. * k) *
               std::atan(h / std::sqrt(-h - std::pow(h, 2.) + k)) +
           2. * std::sqrt(1. - 4. * h + 4. * k) *
               std::atan(std::sqrt(-h - std::pow(h, 2.) + k) / h) -
           8. * h * std::sqrt(1. - 4. * h + 4. * k) *
               std::atan(std::sqrt(-h - std::pow(h, 2.) + k) / h) +
           8. * k * std::sqrt(1. - 4. * h + 4. * k) *
               std::atan(std::sqrt(-h - std::pow(h, 2.) + k) / h) -
           2. * std::atan(std::sqrt(4. * std::pow(h, 3.) +
                                    std::pow(h, 2.) * (3. - 4. * k) +
                                    k * (1. + 4. * k) - h * (1. + 8. * k)) /
                          h) -
           2. * h * (3. + 4. * std::pow(h, 2.)) *
               std::atanh(2. * std::sqrt((h + std::pow(h, 2.) - k) /
                                         (-1. + 4. * h - 4. * k))) +
           3. * h * std::log(1. + 4. * std::pow(h, 2.)) +
           4. * std::pow(h, 3.) * std::log(1. + 4. * std::pow(h, 2.)) -
           6. * h *
               std::log(2. * std::sqrt(-h - std::pow(h, 2.) + k) +
                        std::sqrt(1. - 4. * h + 4. * k)) -
           8. * std::pow(h, 3.) *
               std::log(2. * std::sqrt(-h - std::pow(h, 2.) + k) +
                        std::sqrt(1. - 4. * h + 4. * k))) /
          24.;
    }
    std::cout << std::setprecision(20) << "Gradient = [" << std::endl;
    std::cout << std::setprecision(20) << "  A -> "
              << our_moments.volume_gradient().getGradA() << std::endl
              << std::setprecision(20) << "  B -> "
              << our_moments.volume_gradient().getGradB() << std::endl
              << std::setprecision(20) << " Tx -> "
              << our_moments.volume_gradient().getGradTx() << std::endl
              << std::setprecision(20) << " Ty -> "
              << our_moments.volume_gradient().getGradTy() << std::endl
              << std::setprecision(20) << " Tz -> "
              << our_moments.volume_gradient().getGradTz() << std::endl
              << std::setprecision(20) << " Rx -> "
              << our_moments.volume_gradient().getGradRx() << std::endl
              << std::setprecision(20) << " Ry -> "
              << our_moments.volume_gradient().getGradRy() << std::endl
              << std::setprecision(20) << " Rz -> "
              << our_moments.volume_gradient().getGradRz() << std::endl
              << "]" << std::endl;
    std::cout << std::setprecision(20)
              << "Surface EXACT  = " << exact_surface_area << std::endl;
    std::cout << std::setprecision(20)
              << "Surface IRL    = " << our_surface_area << std::endl;
    std::cout << std::setprecision(20) << "Normal IRL     = " << our_avg_normal
              << std::endl;
    std::cout << std::setprecision(20)
              << "Mean curv IRL     = " << our_avg_mean_curvature << std::endl;
    std::cout << std::setprecision(20)
              << "Gaussian curv IRL = " << our_avg_gaussian_curvature
              << std::endl;
    std::cout << std::setprecision(20)
              << "Vfrac unclipped EX  = " << exact_volume / poly_vol
              << std::endl;
    std::cout << std::setprecision(20)
              << "Vfrac unclipped IRL = " << our_moments.volume() / poly_vol
              << std::endl;
    std::cout << std::setprecision(20) << "GradZ unclipped EX  = "
              << exact_volume_gradk / std::pow(poly_vol, 2.0 / 3.0)
              << std::endl;
    std::cout << std::setprecision(20) << "GradZ unclipped IRL = "
              << our_moments.volume_gradient().getGradTz() /
                     std::pow(poly_vol, 2.0 / 3.0)
              << std::endl;
    std::cout << std::setprecision(20) << "GradZ unclipped FD = "
              << gradZ_FD / std::pow(poly_vol, 2.0 / 3.0) << std::endl;
    std::cout << "Diff Surface EX/IRL = "
              << fabs(our_surface_area - exact_surface_area) /
                     std::pow(poly_vol, 2.0 / 3.0)
              << std::endl;
    std::cout << "Diff Vfrac EX/IRL   = "
              << fabs(our_moments.volume() - exact_volume) / poly_vol
              << std::endl;
    std::cout << "Diff GradZ EX/FD   = "
              << fabs(gradZ_FD - exact_volume_gradk) /
                     std::pow(poly_vol, 2.0 / 3.0)
              << std::endl;
    std::cout << "Diff GradZ EX/IRL   = "
              << fabs(our_moments.volume_gradient().getGradTz() -
                      exact_volume_gradk) /
                     std::pow(poly_vol, 2.0 / 3.0)
              << std::endl;

    std::cout << "-------------------------------------------------------------"
                 "---------------------------------------------------------"
              << std::endl;

    max_volume_error =
        max_volume_error > fabs(our_moments.volume() - exact_volume) / poly_vol
            ? max_volume_error
            : fabs(our_moments.volume() - exact_volume) / poly_vol;
    max_gradient_error =
        max_gradient_error > fabs(our_moments.volume_gradient().getGradTz() -
                                  exact_volume_gradk) /
                                 std::pow(poly_vol, 2.0 / 3.0)
            ? max_gradient_error
            : fabs(our_moments.volume_gradient().getGradTz() -
                   exact_volume_gradk) /
                  std::pow(poly_vol, 2.0 / 3.0);
    max_surface_error =
        max_surface_error > fabs(our_surface_area - exact_surface_area) /
                                std::pow(poly_vol, 2.0 / 3.0)
            ? max_surface_error
            : fabs(our_surface_area - exact_surface_area) /
                  std::pow(poly_vol, 2.0 / 3.0);
    rms_volume_error += fabs(our_moments.volume() - exact_volume) *
                        fabs(our_moments.volume() - exact_volume) / poly_vol /
                        poly_vol;
    rms_gradient_error +=
        fabs(our_moments.volume_gradient().getGradTz() - exact_volume_gradk) *
        fabs(our_moments.volume_gradient().getGradTz() - exact_volume_gradk) /
        std::pow(poly_vol, 4.0 / 3.0);
    rms_surface_error += fabs(our_surface_area - exact_surface_area) *
                         fabs(our_surface_area - exact_surface_area) /
                         std::pow(poly_vol, 4.0 / 3.0);

    // if (fabs(our_moments.volume_gradient().getGradTz() - exact_volume_gradk)
    // /
    //         std::pow(poly_vol, 2.0 / 3.0) >
    //     1.0e-6)
    //   exit(1);
  }
  rms_volume_error = sqrt(rms_volume_error / static_cast<double>(Ntests));
  rms_gradient_error = sqrt(rms_gradient_error / static_cast<double>(Ntests));
  rms_surface_error = sqrt(rms_surface_error / static_cast<double>(Ntests));

  std::cout << "Max surface error   = " << max_surface_error << std::endl;
  std::cout << "RMS surface error   = " << rms_surface_error << std::endl;
  std::cout << "Max volume error    = " << max_volume_error << std::endl;
  std::cout << "RMS volume error    = " << rms_volume_error << std::endl;
  std::cout << "Max gradient error  = " << max_gradient_error << std::endl;
  std::cout << "RMS gradient error  = " << rms_gradient_error << std::endl;
  std::cout << "-------------------------------------------------------------"
               "---------------------------------------------------------"
            << std::endl;

  EXPECT_NEAR(max_volume_error, 0.0, 1.0e-13);
}

TEST(ParaboloidIntersection, ProgressiveDistanceSolver) {
  AlignedParaboloid aligned_paraboloid;
  aligned_paraboloid.a() = 10.0;
  aligned_paraboloid.b() = 20.0;
  std::array<double, 3> angles{{M_PI / 10.0, M_PI / 5.0}};
  // std::array<double, 3> angles{{0.0, 0.0}};
  std::array<double, 3> translations{{0.0, 0.0, 0.0}};
  ReferenceFrame frame(Normal(1.0, 0.0, 0.0), Normal(0.0, 1.0, 0.0),
                       Normal(0.0, 0.0, 1.0));
  UnitQuaternion x_rotation(angles[0], frame[0]);
  UnitQuaternion y_rotation(angles[1], frame[1]);
  UnitQuaternion z_rotation(angles[2], frame[2]);
  auto total_rotation = x_rotation * y_rotation * z_rotation;
  total_rotation.normalize();
  frame = total_rotation * frame;
  auto datum = -Pt::fromArray(translations);
  Paraboloid paraboloid(datum, frame, aligned_paraboloid.a(),
                        aligned_paraboloid.b());

  auto cube = RectangularCuboid::fromBoundingPts(Pt(-1.0, -1.0, -1.0),
                                                 Pt(1.0, 1.0, 1.0));
  std::random_device
      rd;  // Get a random seed from the OS entropy device, or whatever
  std::mt19937_64 eng(rd());  // Use the 64-bit Mersenne Twister 19937
                              // generator and seed it with entropy.
  std::uniform_real_distribution<double> random_vfrac(0.0, 1.0);

  double max_error = 0.0;
  double tolerance = 1.0e-14;
  int Ntest = 1e4;
  for (int i = 0; i < Ntest; ++i) {
    double vfrac_required = random_vfrac(eng);
    ProgressiveDistanceSolverParaboloid<RectangularCuboid> solver(
        cube, vfrac_required, tolerance, paraboloid);
    double distance = solver.getDistance();
    Paraboloid new_paraboloid(datum + distance * frame[2], frame,
                              aligned_paraboloid.a(), aligned_paraboloid.b());
    double error =
        std::fabs(getVolumeFraction(cube, new_paraboloid) - vfrac_required);
    max_error = std::max(max_error, error);
    // if (error > 1.0e-12) {
    // std::cout << std::setprecision(20) << "VFRAC = " << vfrac_required;
    // std::cout << std::setprecision(20) << " -- distance = " << distance;
    // std::cout << std::setprecision(20) << " -- error = " << error <<
    // std::endl;
    if (error > 1.0e-12) {
      exit(-1);
    }
  }

  std::cout << std::setprecision(20) << Ntest
            << " tests -- max error = " << max_error << std::endl;

  EXPECT_NEAR(max_error, 0.0, 10.0 * tolerance);
}

TEST(ParaboloidIntersection, Armadillo) {
  std::ifstream myfile("bunny.vtk");
  std::string line;
  char space_char = ' ';
  std::vector<Pt> point_list{};
  std::vector<std::array<UnsignedIndex_t, 3>> triangle_mapping{};
  if (myfile.is_open()) {
    std::vector<std::string> words{};
    bool read_points = false;
    bool read_connectivity = false;
    while (getline(myfile, line)) {
      std::stringstream line_stream(line);
      std::string split_line;
      while (std::getline(line_stream, split_line, space_char)) {
        words.push_back(split_line);
      }

      if (read_points) {
        for (unsigned i = 0; i < words.size() / 3; i++) {
          point_list.push_back(Pt(std::stod(words[3 * i + 0]),
                                  std::stod(words[3 * i + 1]),
                                  std::stod(words[3 * i + 2])));
        }
      }
      if (read_connectivity) {
        for (unsigned i = 0; i < words.size() / 3; i++) {
          triangle_mapping.push_back(std::array<UnsignedIndex_t, 3>{
              static_cast<UnsignedIndex_t>(std::stoi(words[3 * i + 0])),
              static_cast<UnsignedIndex_t>(std::stoi(words[3 * i + 1])),
              static_cast<UnsignedIndex_t>(std::stoi(words[3 * i + 2]))});
        }
      }
      if (words.size() == 0) {
        read_points = false;
        read_connectivity = false;
      } else if (words[0] == "POINTS") {
        read_points = true;
      } else if (words[0] == "CONNECTIVITY") {
        read_connectivity = true;
      } else if (words[0] == "CELL_DATA") {
        read_connectivity = false;
      }
      words.clear();
    }
    myfile.close();
  }
  std::cout << "THERE ARE " << point_list.size() << " POINTS!" << std::endl;
  std::cout << "THERE ARE " << triangle_mapping.size() << " TRIANGLES!"
            << std::endl;

  // double scale = 1.0e-2;
  double scale = 1.0;
  for (int i = 0; i < point_list.size(); i++) {
    point_list[i] *= scale;
  }
  PolyhedronConnectivity connectivity(triangle_mapping);
  GeneralPolyhedron armadillo(point_list, &connectivity);

  HalfEdgePolyhedronParaboloid<Pt> half_edge;

  for (UnsignedIndex_t i = 0; i < 1; ++i) {
    AlignedParaboloid aligned_paraboloid;
    ReferenceFrame orig_frame(Normal(1.0, 0.0, 0.0), Normal(0.0, 1.0, 0.0),
                              Normal(0.0, 0.0, 1.0));
    double angles[3] = {0.0, 0.0, 0.0};
    Pt translations(0.0, 0.0, 0.0);
    aligned_paraboloid.a() = 1.0;
    aligned_paraboloid.b() = 1.0;

    aligned_paraboloid.a() = -3.0;
    aligned_paraboloid.b() = 3.0;
    angles[0] = M_PI / 2.0;
    angles[1] = M_PI;
    // angles[2] = 0;
    // translations[0] = 0.0;
    translations[1] = -0.3;
    translations[2] = -0.1;

    auto frame = orig_frame;
    UnitQuaternion x_rotation(angles[0], frame[0]);
    UnitQuaternion y_rotation(angles[1], frame[1]);
    UnitQuaternion z_rotation(angles[2], frame[2]);
    frame = x_rotation * y_rotation * z_rotation * frame;
    for (auto& vertex : armadillo) {
      Pt tmp_pt = vertex + translations;
      for (UnsignedIndex_t d = 0; d < 3; ++d) {
        vertex[d] = frame[d] * tmp_pt;
      }
    }

    std::string poly_filename = "cell_" + std::to_string(i);
    std::string surf_filename = "surface_" + std::to_string(i);
    armadillo.setHalfEdgeVersion(&half_edge);
    auto seg_half_edge = half_edge.generateSegmentedPolyhedron();
    auto poly_vol = seg_half_edge.calculateVolume();

    for (auto& face : seg_half_edge) {
      auto normal = Normal(0.0, 0.0, 0.0);
      const auto starting_half_edge = face->getStartingHalfEdge();
      auto current_half_edge = starting_half_edge;
      auto next_half_edge = starting_half_edge->getNextHalfEdge();
      const auto& start_location =
          starting_half_edge->getPreviousVertex()->getLocation();
      do {
        normal += crossProduct(
            current_half_edge->getVertex()->getLocation() - start_location,
            next_half_edge->getVertex()->getLocation() - start_location);
        current_half_edge = next_half_edge;
        next_half_edge = next_half_edge->getNextHalfEdge();
      } while (next_half_edge != starting_half_edge);
      normal.normalize();
      face->setPlane(Plane(normal, normal * start_location));
    }

    Paraboloid paraboloid(-translations, frame, aligned_paraboloid.a(),
                          aligned_paraboloid.b());

    std::cout << "CELL READY" << std::endl;

    auto amr_volume_dummy = intersectPolyhedronWithParaboloidAMR<Volume>(
        &seg_half_edge, &half_edge, aligned_paraboloid, 5,
        poly_filename);  // This prints the AMR triangles
    auto amr_moments = intersectPolyhedronWithParaboloidAMR<VolumeMoments>(
        &seg_half_edge, &half_edge, aligned_paraboloid, 15);
    // // Move centroid to global reference frame
    // auto centroid = IRL::Pt(0.0, 0.0, 0.0);
    // for (std::size_t d = 0; d < 3; ++d) {
    //   for (std::size_t n = 0; n < 3; ++n) {
    //     centroid[n] += frame[d][n] * amr_moments.centroid()[d];
    //   }
    // }
    // centroid -= amr_moments.volume() * translations;
    // amr_moments.centroid() = centroid;

    std::cout << "AMR VOLUME = " << amr_moments.volume() << std::endl;

    ParametrizedSurfaceOutput surface(
        Paraboloid(Pt(0.0, 0.0, 0.0),
                   ReferenceFrame(Normal(1.0, 0.0, 0.0), Normal(0.0, 1.0, 0.0),
                                  Normal(0.0, 0.0, 1.0)),
                   aligned_paraboloid.a(), aligned_paraboloid.b()));

    auto start = std::chrono::system_clock::now();
    auto our_moments = intersectPolyhedronWithParaboloid<VolumeMoments>(
        &seg_half_edge, &half_edge, aligned_paraboloid, &surface);
    auto end = std::chrono::system_clock::now();
    std::chrono::duration<double> runtime = end - start;
    std::cout << "IRL VOLUME = " << our_moments.volume() << std::endl;
    std::cout << "     ERROR = "
              << std::abs(amr_moments.volume() - our_moments.volume()) /
                     amr_moments.volume()
              << std::endl;
    printf("Total IRL run time: %20f \n\n", runtime.count());

    // auto volume_and_surface = getVolumeMoments<
    //     AddSurfaceOutput<VolumeMoments, ParametrizedSurfaceOutput>,
    //     HalfEdgeCutting>(dodeca_unrotated, paraboloid);
    // auto& our_moments = volume_and_surface.getMoments();
    // auto& surface = volume_and_surface.getSurface();
    const double length_scale = 1.0e-3;
    TriangulatedSurfaceOutput triangulated_surface =
        surface.triangulate(length_scale);
    triangulated_surface.write(surf_filename);

    // VTKOutput vtk_io("armadillo_out", "viz", BasicMesh(1, 1, 1, 0));
    // std::vector<ParametrizedSurfaceOutput> surfaces;
    // surface.setLengthScale(length_scale);
    // surfaces.push_back(surface);
    // vtk_io.writeVTKInterface(0.0, surfaces, true);
  }
}

TEST(ParaboloidIntersection, Subgrid) {
  int Ntests = 1;
  double max_error = 0.0, rms_error = 0.0;
  bool first_vertex_on_surface = false;
  HalfEdgePolyhedronParaboloid<Pt> half_edge;
  // Rotate cube
  std::random_device
      rd;  // Get a random seed from the OS entropy device, or whatever
  std::mt19937_64 eng(3);  // Use the 64-bit Mersenne Twister 19937
                           // generator and seed it with entropy.
  static const int ncycles = 1;
  std::uniform_real_distribution<double> random_rotation(-0.5 * M_PI,
                                                         0.5 * M_PI);
  std::uniform_real_distribution<double> random_coeffs_a(-5.0, 5.0);
  std::uniform_real_distribution<double> random_coeffs_b(-5.0, 5.0);
  std::uniform_real_distribution<double> random_translation(-0.5, 0.5);

  for (int i = 0; i < Ntests; i++) {
    auto cube = RectangularCuboid::fromBoundingPts(Pt(-0.5, -0.5, -0.5),
                                                   Pt(0.5, 0.5, 0.5));

    AlignedParaboloid aligned_paraboloid;
    ReferenceFrame orig_frame(Normal(1.0, 0.0, 0.0), Normal(0.0, 1.0, 0.0),
                              Normal(0.0, 0.0, 1.0));
    double angles[3] = {random_rotation(eng), random_rotation(eng), 0.0};
    Pt translations(random_translation(eng), random_translation(eng),
                    random_translation(eng));
    aligned_paraboloid.a() = random_coeffs_a(eng);
    aligned_paraboloid.b() = random_coeffs_b(eng);

    aligned_paraboloid.a() = 2000.0;
    aligned_paraboloid.b() = 0.0;
    // angles[0] = 0.0;
    // angles[1] = 0.0;
    // angles[2] = 0.0;
    translations[0] = 0.0;
    translations[1] = 0.0;
    translations[2] = -10.0;

    auto frame0 = orig_frame;
    UnitQuaternion x_rotation0(angles[0], frame0[0]);
    UnitQuaternion y_rotation0(angles[1], frame0[1]);
    UnitQuaternion z_rotation0(angles[2], frame0[2]);
    frame0 = x_rotation0 * y_rotation0 * z_rotation0 * frame0;
    for (auto& vertex : cube) {
      Pt tmp_pt = vertex;
      for (UnsignedIndex_t d = 0; d < 3; ++d) {
        vertex[d] = frame0[d] * tmp_pt;
      }
    }

    angles[0] = 0.0;
    angles[1] = 0.0;
    angles[2] = 0.0;

    std::cout << "-------------------------------------------------------------"
                 "---------------------------------------------------------"
              << std::endl;
    std::cout << "Case setup." << std::endl;
    std::cout << "-------------------------------------------------------------"
                 "---------------------------------------------------------"
              << std::endl;

    std::cout << std::setprecision(20)
              << "aligned_paraboloid.a() = " << aligned_paraboloid.a() << ";"
              << std::endl;
    std::cout << std::setprecision(20)
              << "aligned_paraboloid.b() = " << aligned_paraboloid.b() << ";"
              << std::endl;
    std::cout << std::setprecision(20) << "angles[0] = " << angles[0] << ";"
              << std::endl;
    std::cout << std::setprecision(20) << "angles[1] = " << angles[1] << ";"
              << std::endl;
    std::cout << std::setprecision(20) << "angles[2] = " << angles[2] << ";"
              << std::endl;
    std::cout << std::setprecision(20)
              << "translations[0] = " << translations[0] << ";" << std::endl;
    std::cout << std::setprecision(20)
              << "translations[1] = " << translations[1] << ";" << std::endl;
    std::cout << std::setprecision(20)
              << "translations[2] = " << translations[2] << ";" << std::endl;

    if (first_vertex_on_surface) translations[2] = 0.0;

    auto frame = orig_frame;
    UnitQuaternion x_rotation(angles[0], frame[0]);
    UnitQuaternion y_rotation(angles[1], frame[1]);
    UnitQuaternion z_rotation(angles[2], frame[2]);
    frame = x_rotation * y_rotation * z_rotation * frame;
    for (auto& vertex : cube) {
      Pt tmp_pt = vertex + translations;
      for (UnsignedIndex_t d = 0; d < 3; ++d) {
        vertex[d] = frame[d] * tmp_pt;
      }
    }

    double local_space_translation = 0.0;
    if (first_vertex_on_surface) {
      for (auto& vertex : cube) {
        Pt tmp_pt = vertex;
        local_space_translation =
            -aligned_paraboloid.a() * vertex[0] * vertex[0] -
            aligned_paraboloid.b() * vertex[1] * vertex[1] - vertex[2];
        break;
      }
      for (auto& vertex : cube) {
        vertex[2] += local_space_translation;
      }
    }
    translations += local_space_translation * frame[2];

    std::cout << "-------------------------------------------------------------"
                 "---------------------------------------------------------"
              << std::endl;
    std::cout << "IRL volume computation." << std::endl;
    std::cout << "-------------------------------------------------------------"
                 "---------------------------------------------------------"
              << std::endl;
    std::string poly_filename = "cell_" + std::to_string(i);
    std::string surf_filename = "surface_" + std::to_string(i);
    cube.setHalfEdgeVersion(&half_edge);
    auto seg_half_edge = half_edge.generateSegmentedPolyhedron();
    auto poly_vol = seg_half_edge.calculateVolume();

    for (auto& face : seg_half_edge) {
      auto normal = Normal(0.0, 0.0, 0.0);
      const auto starting_half_edge = face->getStartingHalfEdge();
      auto current_half_edge = starting_half_edge;
      auto next_half_edge = starting_half_edge->getNextHalfEdge();
      const auto& start_location =
          starting_half_edge->getPreviousVertex()->getLocation();
      do {
        normal += crossProduct(
            current_half_edge->getVertex()->getLocation() - start_location,
            next_half_edge->getVertex()->getLocation() - start_location);
        current_half_edge = next_half_edge;
        next_half_edge = next_half_edge->getNextHalfEdge();
      } while (next_half_edge != starting_half_edge);
      normal.normalize();
      face->setPlane(Plane(normal, normal * start_location));
    }

    Paraboloid paraboloid(-translations, frame, aligned_paraboloid.a(),
                          aligned_paraboloid.b());

    auto amr_volume_dummy = intersectPolyhedronWithParaboloidAMR<Volume>(
        &seg_half_edge, &half_edge, aligned_paraboloid, 10,
        poly_filename);  // This prints the AMR triangles
    auto amr_moments = intersectPolyhedronWithParaboloidAMR<VolumeMoments>(
        &seg_half_edge, &half_edge, aligned_paraboloid, 17);
    // Move centroid to global reference frame
    auto centroid = IRL::Pt(0.0, 0.0, 0.0);
    for (std::size_t d = 0; d < 3; ++d) {
      for (std::size_t n = 0; n < 3; ++n) {
        centroid[n] += frame[d][n] * amr_moments.centroid()[d];
      }
    }
    centroid -= amr_moments.volume() * translations;
    amr_moments.centroid() = centroid;

    ParametrizedSurfaceOutput surface(
        Paraboloid(Pt(0.0, 0.0, 0.0),
                   ReferenceFrame(Normal(1.0, 0.0, 0.0), Normal(0.0, 1.0, 0.0),
                                  Normal(0.0, 0.0, 1.0)),
                   aligned_paraboloid.a(), aligned_paraboloid.b()));
    auto our_moments = intersectPolyhedronWithParaboloid<VolumeMoments>(
        &seg_half_edge, &half_edge, aligned_paraboloid, &surface);
    // auto volume_and_surface = getVolumeMoments<
    //     AddSurfaceOutput<VolumeMoments, ParametrizedSurfaceOutput>,
    //     HalfEdgeCutting>(dodeca_unrotated, paraboloid);
    // auto& our_moments = volume_and_surface.getMoments();
    // auto& surface = volume_and_surface.getSurface();
    const double length_scale = 0.0025;
    TriangulatedSurfaceOutput triangulated_surface =
        surface.triangulate(length_scale);
    triangulated_surface.write(surf_filename);

    std::cout << seg_half_edge;
    VTKOutput vtk_io("cube_out", "viz", BasicMesh(1, 1, 1, 0));
    std::vector<ParametrizedSurfaceOutput> surfaces;
    surface.setLengthScale(length_scale);
    surfaces.push_back(surface);
    vtk_io.writeVTKInterface(0.0, surfaces, true);

    // auto our_moments = getVolumeMoments<VolumeMoments, HalfEdgeCutting>(
    //     dodeca_unrotated, paraboloid);

    std::cout << "-------------------------------------------------------------"
                 "---------------------------------------------------------"
              << std::endl;
    std::cout << "Test " << i + 1 << "/" << Ntests << std::endl;
    // error = fabs(our_moments - moments[0]);
    if (aligned_paraboloid.a() * aligned_paraboloid.b() > 0.0)
      std::cout << "ELLIPTIC" << std::endl;
    else if (aligned_paraboloid.a() * aligned_paraboloid.b() < 0.0)
      std::cout << "HYPERBOLIC" << std::endl;
    else
      std::cout << "PARABOLIC" << std::endl;
    // std::cout << std::setprecision(20) << "Volume polyhedron = " << poly_vol
    //           << std::endl;
    std::cout << std::setprecision(20)
              << "Vfrac unclipped IRL = " << our_moments.volume() / poly_vol
              << std::endl;
    std::cout << std::setprecision(20)
              << "Vfrac unclipped AMR = " << amr_moments.volume() / poly_vol
              << std::endl;
    std::cout << "Diff AMR/IRL = "
              << fabs(our_moments.volume() - amr_moments.volume()) / poly_vol
              << std::endl;
    std::cout << std::setprecision(20) << "Centroid unclipped AMR = "
              << amr_moments.centroid() / safelyEpsilon(amr_moments.volume())
              << std::endl;
    std::cout << std::setprecision(20) << "Centroid unclipped IRL = "
              << our_moments.centroid() / safelyEpsilon(our_moments.volume())
              << std::endl;
    std::cout << std::setprecision(20) << "Diff centroid AMR/IRL = "
              << Pt(fabs(our_moments.centroid()[0] - amr_moments.centroid()[0]),
                    fabs(our_moments.centroid()[1] - amr_moments.centroid()[1]),
                    fabs(our_moments.centroid()[2] - amr_moments.centroid()[2]))
              << std::endl;

    std::cout << "-------------------------------------------------------------"
                 "---------------------------------------------------------"
              << std::endl;

    max_error =
        max_error > fabs(our_moments.volume() - amr_moments.volume()) / poly_vol
            ? max_error
            : fabs(our_moments.volume() - amr_moments.volume()) / poly_vol;
    rms_error += fabs(our_moments.volume() - amr_moments.volume()) *
                 fabs(our_moments.volume() - amr_moments.volume()) / poly_vol /
                 poly_vol;

    if (fabs(our_moments.volume() - amr_moments.volume()) / poly_vol > 1.0e-10)
      exit(-1);
    if (magnitude(
            Pt(fabs(our_moments.centroid()[0] - amr_moments.centroid()[0]),
               fabs(our_moments.centroid()[1] - amr_moments.centroid()[1]),
               fabs(our_moments.centroid()[2] - amr_moments.centroid()[2]))) >
        1.0e-12)
      exit(-1);
  }
  rms_error = sqrt(rms_error / static_cast<double>(Ntests));

  std::cout << "Max error = " << max_error << std::endl;
  std::cout << "RMS error = " << rms_error << std::endl;
  std::cout << "-------------------------------------------------------------"
               "---------------------------------------------------------"
            << std::endl;

  EXPECT_NEAR(max_error, 0.0, 1.0e-12);
}

}  // namespace
